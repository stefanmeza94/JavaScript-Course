HOW JAVASCRIPT WORKS BEHIND THE SCENES

JavaScript is a high-level, prototype-based-object-oriented, multi-paradigm, interpreted or just-in-time complied, dynamic, single-threaded, gargabe-collected programming language with first-class functions and a non-blocking event loop concurency model. 

Ajmo sada da razlozimo ovu ogromnu definiciju javescript na pojedinacne delove.

1) High-level: Svaki program koji koristimo na nasem racunaru zahteva odredjene resurse hardware-a kao sto su ram memorija, procesor da bi se uspesno izvrsavali. E sada postoje low-level jezici kao sto je C, gde moramo manuelno da upravljamo ovim resursima, ako zahtevamo npr kompijuter za deo memorije da bi kreirali novu promenljivu. S druge strane postoje high-level jezici kao sto su npr JavaScript i Python gde nemoramo manuelno da upravljamo tim hardverskim resursima. Ovi jezici imaju neki vid apstrakcije koji resava taj poso upravljanja hadverom umesto nas. Ovo naravno cini high-level jezike dosta lakse za ucenje od low-level jezika. Losa strana high-level jezika je sto oni nikada nece biti brzi kao low-level jezici i nece moci da se optimizuju kao u low-level jeziku. Jedna od glavnih stvari koja resava to upravljanje memorijom za nas jeste garbage-collection.
2) Garbage-collecion: To je prakticno algoritam unutar javascript engine-a koji automatski brise sve nekoriscene objekte iz kompijuterske memorije kako ne bi prenatrpao memoriju sa nepotrebnim stvarima. Kao da javascript ima nekog cistaca u sebi koji s vremena na vreme cisti memoriju kako mi ne bi morali to manuelno da radimo (kao sto bi morali da pisemo kod u nekom low-level jeziku poput C)
3) Interpreted or Just-in-time compiled: Ovu sekciju cemo obratiti malo kasnije ali za sada je bitno da razumemo da nas procesor u racunaru razume samo 0 i 1. To znaci da svaki program koji napisemo u kodu mora na kraju da se prevede u nule i jedinice kako bi se izvrsio. To se drugacije naziva masinski kod. Posto to naravno nije prakticno za kucanje mi pisemo javascript kod koji se zapravo apstrakcija od masinskog koda. Naravno na kraju ovaj kod mora da se prevede u masinski kod kako bi ga nas procesor u racunaru izvrsio. Taj proces prevodjenja javascript koda u masinski kod moze da se desava ili pomocu compiler-a ili interpretering. Na kraju da spomenemo da se ovo prevodjenje js koda u masinski desava u javascript enginu.
4) Multi-paradigm: Jedna od stavri koja cini javascript jezik jako popularnim jeste sto je on multi-paradigm jezik. Sta to znaci? U programiranju paradigma jeste pristup i razmisljanje na koj nacin ce da se pristupi skutruiranju koda koji ce da upravlja nasim stilom kodiranja i razlitim tehnikama u projektu koji koristi odredjenu paradigmu. Tri popularne paradigme jesu: 1) Proceduralno programiranje; 2) Funkcionalno programiranje (FP); 3) Objektno-orijentisano programiranje (OOP). Postoje jezici koji su samo proceduralni jezici ili samo objektno-orijentisani jezici ili samo funckonalni jezici. Ali javascript podrzava sve tri pomenute paradigme, sto ga cini jako flexibilnim za koriscenje.
5) Prototype-based, object-oriented: Ukratko receno gotovo sve u javascriptu jesu objekti, osim naravno primitvih vrednosti (kao sto su stringovi, brojevi ili boolean vrednosti). Array su zapravo isto objekti. Ako se zapitamo zasto je moguce da napravimo array i da kasnije na tom array mozemo da koristimo neku od array funkcija (map, reduce, filter, some, every, find) to je moguce zahvaljajuci prototajpu. Svaki array koji napravimo on se kreira od array nacrta koji se zove prototype, i taj prototype sadrzi sve ove metode koje nas novo napravljeni array nasledjuje od tog prototype posto je od njega nastao. Vise o tome u delu o Objektno-orijentisanom-programiranju.
6) First-class functions: Ovo zapravo znaci da su funckije tretirane isto kao obicne promenljive. To dalje vodi do toga da mozemo da prosledjujemo funkcije unutar druge funckije, cak mozemo i da vracamo funckije iz funckije. To naravno omogucava da koristimo funckionalno programiranje (jedna od tri spomenute paradigme). Nemaju svi jezici ovu mogucnost. 
7) Dynamic: Javascript je dinamicki jezik, to znaci da u javascript ne dodeljujemo tipove (da li je nesto string, da li je broj, boolean ili nesto drugo) podataka kada deklarisemo neku promenljivu i dodelimo joj vrednost. Tip podataka za neku promenljivu postaje poznate tek kada javascript engine izvrsi nas kod. To takodje znaci da vrednost promenljive lako mozemo da promenimo u neku drugu vrednost i samim tim drugi tip. Npr ako je promenljiva u sebi drzala broj, lako mozemo da joj dodelimo string ispod toga tako sto cemo ponovo da joj dodeli neku vrendnost. 
let x = 23; // promenljiva x je prvo drzala broj tip podatka
x = 'word' // sada drzi string tip podataka. To je ono sto znaci dynamically-typed jezik. 
Ovo je dosta drugacije kod ostalih programskih jezika, gde moramo manuelno da dodelimo tip podataka nekoj promenljivoj. Ovo dosta sprecava bug-ove u kodu. Naravno uvek mozemo da koristimo typescript za to ;).
8) Single-threaded i Non-blocking event-loop concurrency model: Ovo je dosta komplikovana tema koju cemo razmatrati malo kasnije, za sada cemo definisati par stvari. Sta je zapravo concurrency model? To je samo fensi termin za to kako se javascript snalazi i kako resava to kada se vise stvari desavaju istovremeno. Zbog cega je to bitno za nas? Zato sto javascript moze da izvrsava stvari samo u jednom threadu. To opet znaci da moze da obavlja samo jedan zadatak istovremeno. Zato je nama potrebno nesto sto ce resavati vise stvari odjednom. Taj thread se definise kao set instrukcija koji se izvrsava u procesoru kompijutera, taj thread je zapravo mesto gde ce se nas kod izvrsiti. Sta ako postoji neki zadatak koji zahteva duze vreme da se izvrsi? Kao sto je na primer kada pozivamo podatke sa backend-a? To zvuci kao da bi to blokiralo taj jedan thread. Naravno da to ne zelimo. Ono sto zelimo je upravo taj non-blocking ponasanje. A to postizemo upravo pomocu event-loopa. Taj event-loop uzima te zadatke za koje je potrebno duze vreme izvrsavanja, izvrsava ih u pozadini i onda ih vraca u taj jedan glavni thread kada se njihovo izvrsavanje u pozadini zavrsi.


THE JAVASCRIPT ENGINE AND RUNTIME
Javascript engine je najprostije receno kompijuterski program, koji izvrsava javascript kod. Svaki browser ima svoj javascript engine, ali najpoznatiji medju njima je svakako google V8 engine. Taj V8 engine pokrece google chrome ali i node.js odnosno javascript runtime koji se izvrsava na serveru. Svaki javascript engine sadrzi call stack i heap. Call stack je mesto gde se izvrsava nas javascript kod koristeci nesto sto se zove execution context. Heap je ne struktuirani memorijski bazen gde se skladiste svi objekti iz nase aplikacije. Pitanje koje se postavlja jeste kako se nas javascript kod prevodi u masinski kod?
Prvo moramo da kazemo par reci o kompilaciji i interpretaciji (obrada, tumacenje). Kao sto smo rekli nas procesor razume samo nule i jedinice. Tako da svaki kompijuterski program mora da bude prebacen u masinski kod. Ovo je moguce ili pomocu kompilacije ili interpretacije. Kod kompilacije ceo kod biva preved u masinski kod odjednom i onda se taj masinski kod zapisuje u portabilni fajl koji moze da se izvrsi na bilo kom kompijuteru. Imamo dva razlita koraka ovde. Prvo se napravi masinski kod a onda se izvrsava u procesoru. Naravno to izvrsavanje moze da se desi daleko posle kompilacije koda. Svaka aplikacija koju koristmo kod nas na kompijuteru je bila kompajlirana nekad pre (prevedena u masinski kod). I mi je sada izvrsavamo mnogo nakon sto se desilo to kompajliranje. Dok sto se tice interpretacije (drugog nacina prevodjenja koda u masinski kod) postoji interpreter koji se izvrsava kroz originali kod i izvrsava liniju po liniju. Ovde nemamo dva koraka kao kod kompajliranja. Ovde se kod cita i izvrsava liniju po liniju, sve u isto vreme. Naravno taj izvorni kod takodje mora da bude preveden u masinski kod ali se to desava bas pred izvrsavanje. Javascript je bio cist interpreterski jezik, ali problem sa interpreterskim jezicima je sto su mnogo sporiji od jezika koji koriste kompajliranje. 
Moderan javascript danas koristi nesto izmedju kompajliranja i interpretiranja sto se naziva just-in-time compilation. Ovaj pristup kompajlira ceo izvorni kod u masinski kod odjednom i onda ga odmah potom izvrsava, tako da i dalje imamo dva koraka kao kod cisto kompajliranih jezika. Razlika je sto kod JIT kompilacije ne postoj taj portabilni fajl koji se pravi kod cisto kompajliranih jezika, vec se izvrsavanje desava odmah nakon prevodjenja celog izvornog koda u masinski kod. Ovo je naravno dosta brze od interpretacije i izvrsavanja koda liniju po liniju. I sada konacno da nastavimo kako se sve to odvija u slucaju javascript-a?
Kada deo javascript koda udje u engine prvi korak je da se taj kod parsira, ili drugacije receno da se procita kod. Tokom tog procesa parsiranja kod se parsira u strukturu podataka koja se naziva abstract synatax tree (AST). Ovde se kod deli na vise delova koja su bitna jeziku, kao sto je odvajanje const ili function kljucne reci i onda cuva sve te delove struktuirane u obliku drveta. Ovaj korako takodje proverava da li postoje neke sintaksne greske. Rezultat te strukture kasnije bice koriscene za stvaranje masinskog koda. Naravno ovaj tree NEMA NIKAKVE VEZE sa DOM-om. Taj abstract synatix tree je samo reprezentacija naseg koda u enginu. Sledeci korak je kompilacija. Uzima se taj generisani AST i kompajlira se u masinski kod. Zatim se taj masinski kod odmah izvrsava. To izvrsavanje se desava u call stack-u unutar engina. Ovde se ne zavrsava proces, sam engine ima jako dobro osmisljenu optimizaciju, engine prvo kreira jako neoptimizovan masinski kod kako bi mogo da krene da se izvrsava sto pre onda se ovaj kod u pozadini optimizuje i ponovo kompajlira tokom vec pokrenutog izvrsavanja programa. Ovo moze da se desava vise puta. Nakon te optimizacije stari kod se zamenjuje tim optimizovanim, bez prekida izvrsavanja. Sve se ovo desava u specijalnom threadu kom mi ne mozemo da pristupimo iz naseg koda.

JAVASCRIPT RUNTIME: runtime mozemo da zamislimo kao veliki kontejner u kom se nalaze sve stvari neophodne za izvrsavanje javascripta (u ovom slucaju) unutar browsera. Srce svakog runtime okruzenja jeste javascript engine. Medjutim sam engine nije dovoljan za moderan javascript. Da bi runtime funkcionisa pravilno, takodje nam je potreban pristup WEB API-ima. U WEB API-e spada sve vezano za dom (document object model), timers, fetch api...WEB API-i su funcktionalnosti koji su obezbedjeni enginu, medjutim one nisu deo samog javascript jezika. Prosto receno javascript dobija pristup ovim WEB API-ima preko globalno dostupnog window objekta. Kao i sam engine i WEP API-i su deo javascript runtime-a. Na kraju svaki js runtime ukljucuje nesto sto se zove callback queue. Ovo je struktura podataka koja sadrzi sve callback funkcije koje su spremne da budu izvrsene. Npr kao kada zakacimo nekom button-u neki event, npr click. Kada se desi event, callback funkcija bice pozvana. Prvo sto se desava nakog tog click eventa jeste da se ta callback funkcija smesta upravo u callback queue strukturu podataka. Zatim cim se call stack isprazni ta callback funkcija biva smestena unutar call stack-a da bi mogla da se izvrsi. Sve ovo se desava pomocu neceg sto se zove event loop. Taj event loop uzima call back funkcije i prebacuje ih u call stack gde mogu da se izvrse. Na kraju da spomenemo da javascript moze da postoji i van broswera, kao sto je slucaj sa node.js. Runtime u node.jsu izgleda slicno kao onaj u browseru samo sto sada ne postoje web api-i (s obzirom da nismo u browseru posto te web api-e obezbedjuju upravo browseri). Umesto njih postoje C++ bindings i thread pool.


EXECUTION CONTEXT AND CALL STACK
Da prepostavimo da je nas kod zavrsio kompajliranje i da treba da krene da se izvrsava. Prvo sto se desava jeste da se kreira globalni execution context za top level kod. To je zapravo kod koji se NE nalazi ni u jednoj funkciji. Dakle u pocetku se izvrsava samo kod koji se nalazi van svake funkcije u kodu. Ako razmislimo ovo ima smisla jer funkcije treba da se izvrse tek kada se pozovu. Sta je zapravo taj execution context? To je apstraktni koncept, ali mozemo da ga definisemo kao neko okruzenje u kom se deo javascripta izvrsava. To je kao kutija koja sadrzi sve neophodne informacije koje su potrebne da se neki kod izvrsi (lokalne promenljive ili argumenti prosledjeni funkciji itd). Javascript kod se uvek izvrsava u execution contextu! Bez obzira koliko veliki kod bio, uvek ce da postoji samo jedan globalni execution context, gde se izvrsava top level kod. Odmah nakon kreiranja globalnog execution contexta desava se izvrsavanje tog top level koda odnosno tog globalnog execution contexta. Kada se zavrsi to izvrsavanje top level koda, funckije konacno pocinju da se izvrsavaju. To funckionise tako sto se za svaki poziv funckije kreira nov execution context koji ce da sadrzi sve neophodne informacije za izvrsavanje te funkcije. Isto vazi i za metoe u kodu jer su zapravo samo funkcije zakacene na objekte! Svi ti execution contexti cine call stak. Kada se zavrsi izvrsavanje svih tih execution contexta odnosno svih funckija engine ce nastaviti da ceka za callback funckije da budu prebacene u call stak kako bi mogle da se izvrse. Te callback funckije prebacuje event loop unutar callstaka (ali tek kada je on prazan). 

Sta sve cini jedan execution context?
Prva stvar koja se nalazi u svakom execution contextu jeste varijabalno okruzenje. 1) U ovom okruzenju su uskladistene sve nase promenljive i funkcije, ali tu je i poseban arguments objekat. Ovaj objekat ce da sadrzi sve argumente koji su prosledjeni nasoj funckiji kojoj trenutni execution context pripada. Da ponovimo da se za svaki poziv funkcije kreira nov execution context! Sve promenljive koje su deklarisane unutar funckije ce zavrsiti u tom varijablnom okruzenju. Funkcije naravno mogu da pristupe i promenljivama van te funkcije. 2) Ovo je moguce zbog neceg sto se zove scope chain. (taj scope - opseg sadrzi reference ka svim promenljivama koje su definisane u odredjenom scopu - opsegu). Da bi se pratio svaki scope chain on je uksladisten u svakom execution contextu. 3) Na kraju svaki execution context dobija svoju THIS kljucnu rec. 
Dakle unutar execution contexta se nalaze tri stvari a to su: 1) Varijabalno okruzenje; 2) Scope chain; 3) THIS promenljiva. Ove tri stvari se generisu tokom faze kreiranja, bas pre izvrsavanja koda. JEDNA NAPOMENA NA KRAJU STO SE TICE ARROW FUNCKIJA. Execution context arrow funkcije nema arguments objekat i THIS promenljivu. Arrow funkcije nemaju pristup objektima sa argumentima i this kljucnom recju. Umesto toga one mogu da koriste arguments objekte i this kljucnu rec od najblize roditeljske funkcije. 

Kada u kodu imamo mnogo funckija pitanje koje se postavlja kako ce engine da prati izvrsavanje svih tih execution contexta (koji se stvaraju za svaku funkciju)? I kako ce da zna gde je trenutno u izvrsavanju? Tu nastupa call stack. Prvo da kazemo sta je to call stack. To je mesto gde se execution contexti nagomilavaju jedan preko drugog kako bi se pratilo izvrsavanje koda. Executon context koji se nalazi na vrh tog call stack-a je onaj koji se trenutno izvrsava! Kada zavrsi izvrsavanje tog execution contexta on ce biti obrisan i sklonjen iz call stack-a i izvrsavanje ce se nastaviti na onaj ispod execution context (koji je sada na vrhu call stack-a). 


SCOPE AND THE SCOPE CHAIN
U prosloj lekicji smo naucili da se svaki execution context sastoji od tri stvari: 1) Variable environment; 2) Scope chain; 3) this keyword. U ovoj lekciji cemo pricati i tome sta je to scope i scope chain. 
Sta je scoping ustvari? On kontrolise kako su nase promenljive iz programa organizovane i kako im se pristupa od strane javascript engine-a. Dakle gde mozemo da pristupimo odredjenoj promenljivoj a gde ne. 
U javascriptu postoji nesto sto se zove lexical scoping. Lexical scoping znaci da nacin na koji su promenljive organizovane i kako im se pristupa jeste u potpunosti kontrolisano od mesta funckije i blokova koda u programskom kodu. Npr funckija koja se nalazi unutar druge funkcije ce uvek imati pristup promenljivama te roditeljske funkcije. 

function first() {
  let a = 10

  let result = function() {
    return a - 2
  }

  return result;
}

...second funkcija ce imati pristup promenljivama koje su deklarisane unutar first funckije. 

Sta je to scope (opseg)? To je prostor ili okruzenje gde su odredjene promenljive deklarisne. U slucaju funkcija to je u sustini varijablno okruzenje koje je se nalazi u execution contextu te funkcije. U javascriptu postoje tri scope-a: 
1) Globalni opseg (scope), 2) funkcijski opseg i 3)blokovni opseg.
Sta je scope of variable? To je ceo region u nasem kodu gde odredjenoj promenljivoj moze da se pristupi. 

Rekli smo da postoje tri scope-a. To su global scope, function scope i block scope.
1) Global scope (globalni opseg): taj globalni ospeg jeste top level kod. To je za promenljive koje su deklarisane van svake funkcije. Ovim promenljivama mozemo da pristupimo bilo gde u kodu, u svim funkcija i u svim blokovima koda. 
2) Svaka funckija kreira funckijski opseg. Promenljive deklarisane unutar funckije bice dostpune samo unutar te funkcije. Ovo se drugacije naziva local scope (lokalni opseg). Van te funckije ne mozemo da pristupimo pormenljivama koje se deklarisane unutar te funkcije. 
3) Nekada su samo funkcije kreirale scope u javascriptu medjutim pocev od ES6 (2015) blokovi takodje obrazuju scope. Tu se podrazumeva sav kod izmedju {} ovih zagrada. Kao sto je if (some condition) {block scope}, for () {block scope}. Promenljive deklarisane unutar nekog bloka koda bice dostupne samo unutar tog bloka. Medjutim JAKO JE VAZNO DA RAZUMEMO DA SE OVO PRIMENJUJE SAMO NA PROMENLJIVE DEKLARISANE SA LET I CONST! Zato kazemo da su let i const promenljive blocked scoped. Dok s druge strane ako kreiramo promenljivu sa VAR kljucnom recju, ona ce i dalje biti dostpuna van tog block scope-a! Bice scopovana unutar roditeljske funkcije ili u globalnom opsegu. Zato za promenljive deklarisane sa VAR kazemo da su funcion scope, NISU block scoped. Sve do 2015 imali smo samo globalni opseg i funkcijski opseg, medjutim sa dolaskom ecma script 2015 uvodi se i block scope (takodje tad su predstavljene i LET i CONST kljucne reci), zato promenljive deklarisane sa VAR ignorisu block scope. Takodje sa es 2015 sve funkcije su takodje block scope (ovo vazi samo ako je scipta u strict modu).  

Opseg (scope) uvek ima pristup svim vanjskim scope-ovima! Dok neka vanjska funckija nikada nece imati pristup neke unutrasnje funkcije. Primer: 

const myName = 'Jonas'

function first() {
  const age = 30

  if (age >= 30) {
    const decade = 3;
    var millenial = true;
  }

  function second() {
    const job = 'teacher';

    console.log(`${myName} is a ${age}-old ${job}`)
  }
}

Ako primenimo pravilo odozgo videcemo da scope second funckije ima pristup scopu first (roditeljske) funkcije, koja dalje ima pristup globalonm opsegu odnosno myName promenljive. Ako scope first funkcije ima pristup globalnom opsegu to znaci da ga ima i opseg second funckije! Zato second funkcija moze da pristupi i age promenljivoj i myName promenljivoj. Ovo se drugacije zove variable lookup in scope chain, uvek ide u smeru na gore. Dok s druge strane scope first funkcije nikada nece imati pristup scope-u second funkcije.


VARIABLE ENVIRONMENT: HOISTING AND THE TDZ(temporal dead zone): 
Jedna od tri stvari koja cini svaki execution context jeste varijabalno okruzenje. Kako se varijable zapravo kreiraju u javascriptu? U javascriptu imamo mehanizam koji se naziva hoisting. Hoisting cini da neki tipovi promenljiva budu dostpune u kodu pre nego sto su zapravo deklarisane. Kako radi hositing? Pre izvrsavanja kompletnog koda, kod se skenira za sve deklarisane promenljive. Za svaku promenljivu koja je pronadjena u kodu kreira se novo svojstvo (property) unutar variable environment object-a. Hoisting ne radi isto za sve tipove promenljiva. 

1) Funckijske deklaracije: funkcijske deklaracije su zapravo hojstovane. Pocetna vrednost u varijabalnom okruzenju je setovana na tu funkciju. Ovo u praski znaci da mozemo da koristimo funkcijske deklaracije pre nego sto su deklarisane u kodu. One su storovane u variable environment object-u pre nego sto kod krene da se izvrsava. Funckijske deklaracije su block scope kada koristimo strict mode, a ako ne koristimo strict mode onda su funkcijske deklaracije function scope.  
2) promenljive deklarisane sa var: promenljive deklarise sa var su takodje hojstovane, ali ako probamo da koristimo var promenljivu pre nego sto je deklarisana u kodu ne dobijamo njenu vrednost, vec dobijamo undefined. Promenljive deklarise sa var su function scope.
3) promenljive deklarisne sa let i const: let i const promenljive nisu hojstovane, tehnicki jesu hojstovane ali njiova vrednost je postavljena na uninitalized, ne postoji vrednost sa kojom mozemo da radimo, tako da u praksi izgleda kao da nisu hojstovane. Ako pokusamo da pristupimo promenljivoj deklarisnom sa let ili const pre nego sto je deklarisana u kodu za takve promenljive kazemo da se nalaze u temporal dead zonu (TDZ). To znaci da ne mozemo da pristupimo promenljivoj od pocetka njenog scope-a do mesta gde je deklarisana u kodu. Ukratko ako probamo da pristupimo nekoj promenljivoj deklarisanoj sa let ili const pre nego sto su deklarisane u kodu dobicemo gresku. Naravno na kraju imajte na umu da su promenljive sa let i const block scope. Postoje samo u blocku u kom su kreirane. 
4) funkcijski izrazi i arrow funkcije: sto se tice function expession-a ili arrow funckija, kod njih zavisi da li su deklarisane sa var, let ili const! Te funkcije su zapravo promenljive tako da se ponasaju na isti nacin kao promenljive. To znaci da funckijski izrazi (f expression) i arrow funkcije deklarise sa var jesu hojstovane i ako probamo da im pristupimo pre nego smo ih deklarisali u kodu dobicemo undefined, ali ako smo ih deklarisali pomocu let ili const ne mozemo da ih koristimo do linije koda na kojoj su deklarisane jer se nalaze u temporal dead zoni, bas kao i normalne promenljive. 

Sto se tice temporal dead zone ona postoji od mesta pocetka scope neke promenljive do mesta gde je promenljiva deklarisana, i u tom delu ne mozemo da pristupimo promenljivoj. To je deo opsega (scope) promenljive gde je promenljiva deklarisana ali ne moze nikako da se koristi.  

const myName = 'Jonas';

if (myName === 'Jonas') {
  console.log(`Jonas is a ${job}`); // ovde dve linije koda bice temporal dead zone za promenljivu job, scope promenljive age
  const age = 2037 - 1991;          // je poceo sa pocetkom ovog if blocka ali sve do linije gde je promenljiva deklarisana necemo moci da joj pristupimo. 
  Greska koja ce da se pojavi - ReferenceError: Cannot acces 'job' before initialization
  const job = 'teacher'; // od ove linije na dole moci cemo da pristupimo promenljivoj job
}


THIS KEYWORD: 
This kljucna rec je specijalna varijabla koja se kreira za svaki execution context odnosno svaku funkciju. To je treca i poslednja komponenta svakog execution contexta. Vrednost this promenljive nije staticna, drugim recima nije uvek ista. Zavisi od toga kako je funkcija pozvana. Njena vrednost je dodeljena tek kada se funkcija pozove. Vrlo je razlicita od obicne vrednosti. Ako setujemo neku promenljivu da ima vrednost 5 ona ce uvek imati vrednost 5 (ukoliko je mi manuelno ne promenio). Medjutim this zavisi od nacina na koji je funkcija pozvana. Sta to zapravo znaci? Hajde da pogledamo 4 nacina na koje funckija moze da se pozove.
1) Prvi nacin da se pozove funkcija je kao metoda, kao funckija zakacena na neki objekat. Kada pozovemo metodu, this kljucna rec unutar te metode ce prosto da pokazuje ka objektu na koji je metoda pozvana. Drugim recima this upucuje na objekat koji poziva metodu. 
2) Sledeci nacin za pozivanje funkcije jeste da prosto pozovemo normalnu funkciju (funkcijske deklaracije i funkcijski izrazi). U ovom slucaju this kljucna rec ce da ima vrednost undefined, ali to vazi samo za strict mode, ako nismo u strict modu this ce da pokazuje ka globalnom objektu sto je u slucaju browsera window objekat. 
3) Sledeci na listi su arrow funkcije. Arrow funkcije ne dobijaju svoju this kljucnu rec. This kljucna rec ce u arrow funkciji da ima vrednost od roditeljske funkcije ili od globalnog opsega. U tehnickom smislu ovo se zove lexical this.
4) I na kraju ako je funckija pozvana kao event listener, onda ce this kljucna rec uvek da pokazuje ka DOM elementu na koji je zakacena handler funkcija. 

Ukoliko koristimo this kljucnu rec u globalnom opsegu ona ce pokazivati na globalni window objekat, bilo da smo u strict modu ili ne!

This nikada nece da pokazuje ka samoj funkciji, takodje this nikada nece da pokazuje ka varijablnom okruzenju funkcije!
Postoje jos neki nacini na koje mozemo da pozovemo funkcije ali o tome nesto kasnije. new, call, apply, bind metode.


PRIMITIVES VS OBJECTS (Primitive vs Reference Types):
Na pocetku da kazemo da u primitvne tipove spadaju: number, string, boolean, undefined, null, symbol, bigInt. Sve ostalo su objekti: object literals, arrays, functions i jos dosta toga.
Kada pricamo o memoriji i o upravljanju memorijom, primitvne tipove zovemo upravo tako, dok objekte zovemo reference type, zbog ralicitog nacina na koji se skladiste u memoriji.
Jos jednom da se podsetimo da da se js engine sastoji od callstack-a i heap-a. U heap delu su uskladisteni svi objekti. Dok se primitivni tipovi skladiste u call stack-u tacnije u execution contextu u kom su deklarisni (execution context se pravi za svaku funkciju). 

Primitivni tipovi:
let age = 30;
let oldAge = age;
age = 31;
console.log(age) // 31
console.log(oldAge) // 30

Kada mi definisemo npr promenljivu let age = 30 sta se zapravo desava u js enginu i u kompijuterskoj memoriji. Prvo ce javascript da stvori jedinstven identifikator sa imenom varijable (u ovom slucaju age). Onda ce deo memorije da bude dodeljen tom identifikatoru sa odredjenom adresom (npr 0001) i konacno vrednost 30 ce da bude uskladistena na toj memoriskoj lokaciji. Znaci u ovom slucaju vrednost 30 ce da bude uskladistena na memorijskoj adresi 0001. Jako bitno da razumemo jeste da ce identifikator (age) da pokazuje ka memorijskoj adresi 0001 a ne na vrednost 30. Mi u praksi kazemo da age promenljiva drzi vrednost 30 ali to zapravo nije tacno. Age je jednak memorijskoj adresi koja drzi vrednost 30. 
Na sledecoj liniji koda mi definisemo novu promenljivu oldAge. Ako znamo da identifikator pokazuje ka memoriskoj adresi taj novi identifikator oldAge sada pokazuje ka istoj memorijskoj adresi 0001 jer smo mu dodelili vrednost promenljive age. Tako da identifikator oldAge pokazuje ka memorijskoj adresi 0001 koja drzi vrednost 30. Medjutim u trecoj liniji koda mi redefinisemo promenljivu age na 31. Memorijska adresa 0001 nece postati 31 jer bi to promenilo i oldAge promenljivu, posto obe pokazuju ka istoj memoriskoj lokaciji. Ono sto ce da se desi jeste da ce novi deo memorije da bude kreiran (npr 0002) i sada ce identifikator age da pokazuje ka toj novoj adresi u memoriji 0002 koja u sebi drzi vrednost 31. Zato na kraju kada prikazemo u konzoli obe vrednosti dobijamo da oldAge ima vrednost 30 a age ima vrednost 31.

Referente vrednosti (objekti):
const me = {
  name: 'Jonas',
  age: 30
}

const friend = me;
friend.age = 27;

console.log(me) // { name: 'Jonas', age: 27 }
console.log(friend) // { name: 'Jonas', age: 27 }

U primeru iznad vidimo da smo promenljivoj friend dodelili vrednost objekta me. Ispod toga menjamo friend objekat i njegovo svojstvo (age) u 27. Kada prikazemo u konzoli oba objekta tj obe promenljive videcemo da su i kod jednog i kod drugog objekta promenjene vrednosti za age, iako mi nismo menjali vrednost kod objekta me. Zasto je to tako? 
Kada kreiramo neki objekat kao sto je ovaj me on se skladisti u heap-u (jednom od delova js engina). U heap-u postoji memorijska adresa (npr D30F) i sama vrednost objekta. Kada smo kreirali ovaj novi objekat me pravi se identifikator sa tim imenom (me) koji zapravo ne pokazuje odma na memorijsku adresu u heap-u gde se skladisti objekat. Umesto toga taj identifikator me pokazuje na novu memorijsku adresu (0003 npr) u call stack-u. Taj novi deo memorije 0003 upucuje na objekat koji se nalazi u heap-u, koristeci memorijsku adresu (D30F iz heap-a) kao njegovu vrednost. Drugim recima taj deo memorije 0003 iz call stack-a sadrzi referencu memorijske lokacije iz heap-a D30F koja ustvari drzi vrednost samog objekat me. Zato objekte nazivamo referentne vrednosti. Ako se pitate zasto ova komplikacija i zato sto se objekti skladiste u heap-u a ne u call stack-u kao obicne primitvne vrednosti, pa zato sto objekti mogu da budu jako kompleksni i jako obimni da bi se sladistili u call stack-u. Taj heap se ponasa kao beskonacan prostor za objekte, dok stack sadrzi samo referencu gde se taj objekat nalazi u heap-u, kako bi mogo da ga pronadje kad bude potreban. 
Dalje u kodu se desava da mi pravimo novi objekat friend, kom dodeljujemo vrednost me objekta. Pravi se novi identifikator friend koji ce da pokazuje ka istoj memorijskoj adresi u call stack-u 0003 (bas kao i me identifikator), ta adresa zadrzi referencu memorijske lokacije u heap-u (D30F) koja drzi vrednost samog objekta. Friend objekat je zapravo sada isti objekat kao i me objekat.
U sledecoj liniji koda (vidi primer iznad) mi menjamo age svojstvo u friend objektu na vrednost 27. Objekat se pronalazi u heap-u i menja se njegovo svojstvo age na 27. Sada kada prikazemo u konzoli friend objekat vidimo da je njegovo svojstvo age promenjeno u 27. Ali ako pogledamo i me objekat videcemo da se i njegovo svojstvo age promenilo u 27, jer kao sto smo rekli me i friend sada pokazuju ka ka istoj memorijskoj lokaciji 0003 koja cuva referencu D30F kao vrednost, a ta referenca zapravo upucuje na memorijsku lokaciju u heap-u D30F u kom je uskladisten sam objekat. 
Ono sto je zanimljivo ovde jeste da smo mi definisali friend objekat sa const kljucnom recju za koje vazi pravilo da ne mozemo da menjamo vrednost. Medjutim to vazi za primitivne tipove, jer mi u ovom slucaju referentih vrednosti tacnije objekta nismo promenili sta cuva memorijska adresa 0003, a to je memorijska lokacija D30F u heap-u. Samo smo promenili svojsvo u tom objektu dok to na sta pokazuje memorijska adresa iz call stack-a 0003 ostaje ista referenta vrednost D30F. 
Sta god promenili u jednom ili drugom objektu (me or friend) to ce se reflektovati na oba objekta. Jer zapravo to su samo dva razlicita identifikatora me i friend koja pokazuju ka istoj memorijskoj adresi 0003 koja cuva referencu memorijske lokacije u heap-u (D30F) koja u sebi cuva samu vrednost objekta. 