ASYNCHRONOUS JAVASCRIPT PROMISES ASYNC_AWAIT AND AJAX

Da bi razumeli sta je to asinhroni kod, prvo moramo da razumemo sta je to sinhroni kod. Vecina koda koju smo do sada pisali jeste bila sinhroni kod. Sinhrono prosto znaci da se kod izvrsava liniju po liniju, tacno onako kako smo definisali u kodu. U primeru ispod, kako prva linija koda krene sa izvrsavanjem, ona ce se izvrisiti u execution threadu (to je deo execution contexta koji inace izvrsava kod u kompijuterskom procesoru). Zatim je sledeca linija koda izvrsena, odmah potom treca linija (alert). Svaka linija koda uvek ceka da prethodna linija zavrsi izvrsavanje. Ovo moze da stvori probleme, kada jedna linija koda zahteva puno vremena da se izvrsi. Kao sto imamo u primeru na trecoj liniji alert('Text set') imamo ovaj alert statement koji kreira alert prozor. Kao sto znamo do sada ovaj alert prozor blokira dalje izvrsavanje koda. Nista nece funkcionisati na stranici sve dok ne stisnemo OK button u alert prozoru. Tek ce tada kod nastaviti sa izvrsavanjem. Tako da je ovaj alert statement vrlo dobar primer nekog procesa koji traje duze vreme i koji samim tim blokira izvrsavanje ostatka koda. 

const p = document.querySelector('.p');
p.textContent = 'My name is Jonas!';
alert('Text set');
p.style.color = 'red';

Ovim smo pokazali zato sto je sinhroni kod los. Blokiranje daljeg izvrsavanja koda nije dobro po UX. Sinhroni kod je sasvim okej u vecini slucajeva, medjutim zamislite da morate da cekate na izvrsavanje nekog timera od pet sekundi da istekne. Za tih 5 sekundi nista na stranici ne bi radilo. Upravo tu upada u pomoc asinhroni kod. Sledeci primer pokazuje taj timer od pet sekundi. 

const p = document.querySelector('.p');
setTimeout(function() {
    p.textContent = 'My name is Jonas!';
}, 5000)
p.style.color = 'red';

Prva linija koda je i dalje sinhrona, tako da ce se izvristi odmah i execution context odmah prelazi na drugu liniju koda. Ali ovde dolazimo do setTimeout funkcije. Ona ce da startuje timer ali na asinhroni nacin. To znaci da ce taj timer da tece u pozadini bez sprecavanja i blokiranja ostatka koda ispod njega. Takodje ovde u timeru registrujemo call back funkciju koja nece biti izvrsena sada vec tek nakon sto timer zavrsi odbrojavanje u pozadini. Ova callback funkcija je upravo asinhroni javascript. Asinhroni je zato sto ce se izvristi tek nakon sto se taj task koji je pokrenut u pozadini zavrsi. To znaci da se registruje callback funkcija (timer se pokrece u pozadini) a nas kod nastavlja odmah sa izvrsavanjem sledece linije koda p.style.color = 'red' bez bilo kakvog blokiranja i zadrzavanja. Tako da glavni kod nije blokiran a izvrsavanje NE CEKA na asinhroni timer da zavrsi svoj poso. To je velika razlika izmedju sinhronog i asinhronog koda. Kada timer konacno zavrsi odbrojavanje od pet sekundi callback funkcija ce konacno biti izvrsena. Dakle ta callback funkcija ce biti izvrsena na kraj ovog koda iako se u kodu ne nalazi na kraju. Asinhron bukvalno znaci da se ne desava u isto vreme. Kao sto smo videli u ovom primeru morali smo da koristimo callback funkciju kako bi primenili to asihrono ponasanje. Medjutim TO NE ZNACI da callback funkcije automatski cine kod asinhronim. Npr array metoda MAP prihvata callback funkciju, medjutim to je ne cini asihronom. Samo specificne funkcije rade na asinhroni nacin (timeri na primer).

Evo jos jedan primer asinhronog koda:

const img = document.querySelector('.dog');
img.src = 'dog.jpg';
img.addEventListener('load', function() {
    img.classList.add('fadeIn');
})
p.style.width = '300px';

Prve dve linije se izvrsavaju sinhrono, jedna za drugom. U drugoj liniji postavljamo src atribut slici koju smo selektovali u prvoj liniji koda. Ova operacija je zapravo asinhrona. Setovanje src atributa na bilo kojoj slici je asinhrona operacija. Jer to zapravo ucitava sliku u pozadini, dok ostatak koda nastavlja da se izvrsava. Ovo naravno ima smila jer zamislite da je slika ogromna, naravno da ne bi voleli da cekamo na nas kod da se ucita cela slika, zato je setovanje src atributa u js asinhrono. Nakon sto se slika ucitala, 'load' event ce da bude emitovan od strane javascripta, tako da mozemo da osluskujemo taj load event i da vrsimu neku akciju usled ucitavanja slike. To je upravo ono sto se desava ovde u kodu. To radimo upravo na trecoj liniji koda. Koristimo addEventListener da bi registrovali callback funkciju za load event. Bas kao u prethodnom primeru obezbedili smo callback funkciju koja ce da bude izvrsena tek kada se slika ucita. Upravo to cini ovaj kod non-blocking. Umesto da blokiramo kod izvrsvanje odmah nastavlja dalje u kodu. I tek kada se slika kompletno ucita, prikazuje se na stranici i load event je emitovan. Posto mi slusamo taj event nasa callback funkcija je konacno izvrsena. Jos jedna bitna stvar da napomenmo jeste da addEventListener ne cini kod asinhronim, bas kao i call back funkcije koje same po sebi ne cine kod asinhronim! Na primer event listener koji osluskuje click na nekon buttonu ne radi nikakav poso u pozadini, prosto ceka na click da se desi, tako da tu ne postoji nikakav asinhroni kod. U primeru iznad sve sto cini kod asinhronim jeste sto slika ucitava asinhrono i mi osluskujemo taj load event preko addEventListener funkcije i cekamo da se desi. Naravno da postoji jos mnogo primera asinhronog ponasanja u javascriptu. AJAX pozivi se smatraju vrv medju najpopularnijim asinhronim kodom u javascriptu. 

Sta je to AJAX zapravo?
AJAX je skracenica za Asynchronous Javascript And XML. On nam omogucava da komunicramo sa remote serverima na asinhroni nacin. U praksi mi radimo ajax pozive u nasem kodu kako bi zahtevali neke podatke od nekog web servera dinamicno, bez reloadovanja stranice. 
Kako zapravo AJAX funckonise? Recimo da imamo nasu javascript aplikaciju koja je pokrenuta u pretrazivacu, sto se drugim recima naziva klijent. Mi zelimo da u nasoj aplikaciji dostavimo neke podatke od web servera, recimo podatke o nekim drzavama. Uz pomoc AJAX mozemo da radimo HTTP request (zahteve) prema serveru koji poseduje ove podatke koji nama trebaju. Zatim ce server da posalje response (odgovor) koji sadrzi te podatke koje smo mi od njega prvobitno trazili. Ova proces od klijenta do servera i nazad se desava asinhrono u pozadini. Naravno postoje razliciti tipovi request-a kao sto su GET request da bi dobili podatke, POST request da posaljemo neke podatke na server, PATCH/PUT request da editujemo neke postojece podatke itd. 

Kada smo pitali srever da nam posalje neke podatke ovaj server obicno sadrzi nesto sto se zove web API. Ovaj web api sadrzi podatke koje smo mi zatrazili. Ali sta je zapravo API?

API je skracenica za Application Programming Interface. API je deo softvera koji moze da se koristi od strane dugog dela softvera, sto prakticno omogucava da aplikacije komunicairaju medjusobno i da razmenjuju informacije. To nije slucaj samo sa web developmentom vec generalno sa programiranjem. U javascriptu i uopste u web developmentu postoji bezbroj api-a, kao sto je DOM API, geolocation API, fetch API itd. Oni se nazivaju api-ima jer su samostalni delovi softvera koji omogucavaju drugim delovimam softvera da komuniciraju izmedju sebe.  

E sada da pricamo o API-ima za koje smo mi zainterosavni u web developmentu. Drugacije ih nazivamo "Online" API. Online api je aplikacija koja je pokrenuta negde na serveru koja prima zahteve za podatke zatim vadi ovde podatke iz neke baze podataka i najzad salje ih nazad klijentu. Ove "Online" apie prosto zovemo samo API, cak moze da se cuje i naziv WEB API. Naravno mi mozemo da naparvimo sami neki WEB API ali to bi zahtevalo backend development, dakle development sa serverima, bazama podataka i ostalo...

Na frontu mi smo zainterosavni za koriscenje 3rd-party API-a, dakle API-e koje drugi developeri cine dostupnim za nas potpuno besplatno (u vecini slucajeva). Postoje api-i za svasta nesto, tipa: podaci o vremenu, podaci o drzavama i gradovima, podaci o letovima, api-i za slanje mejlova i poruka...

Na kraju da spomenemo format podatka api-a. Kao sto smo rekli AJAX je skracenica za Asynchronous Javascript and XML, XML je zapravo fomrat podataka koji je pre koriscen za slanje podatka na webu. Medjutim ovih dana ni jedan api ne koristi vise XML format podataka. Umesto toga vecina api-a danas koristi JSON format podataka. To je prakticno javascript objekat ali konvertovan u string. To ga cini vrlo pogodnim za slanje izmedju klijenta i servera, kao i da se vrlo lako korsti u javascriptu kada podaci dodju do klijenta. 


U javascriptu zapravo postoji mnogo nacina da se odradi AJAX poziv ka serveru. Najvise 'old school' nacin bi bio preko XMLHttpRequest funckije. Ovo je bas star nacina da zatrazimo nesto od servera, medjutim mozda ce vam zatrebati nekad u budcnosti i zato krecemo od njega. Druga stvar jeste da pokazemo kako su AJAX pozivi bili regulisani preko eventa icallback funkcija. Tek nakon doga precicemo na moderniji nacin cinjenja AJAX poziva koji obuhvata promise. 

Prvo sto moramo da uradimo jeste da pozovemo konstrutkro funckiju i da uskladistivmo taj rezultat u neku promenljivu: 

const request = new XMLHttpRequest();

...zatim moramo da postavimo koji request zelimo i prema kom endpointu zelimo da saljemo request. To radimo tako sto pozivmao metodu open() nad requestom koji smo uskladistili kada smo pozvali XMLHttpRequest. Prvi argument open metode jeste vrsta requesta (get, post, delete, patch, put...) a drugi argument jeste endpoint koji gadjamo da bi dobili te podatke koje zelimo.

request.open('GET', 'https://restcountries.com/v3.1/name/serbia');

...treci korak bi bio slanje zahteva, to radimo pomocu metode send();

request.send();

...medjutim ono sto je interesantno ovde jeste da ako sada zelimo da dobijemo te podatke koje vraca server ne mozemo samo da uskladistimo request.send() u neku promenljivu. Razlog zasto to ne mozemo da uradimo jeste zato sto rezultat jos uvek nije tu u tom trenutku kada bi mi smestili rezultat request.send() u neku promenljivu! Taj AJAX poziv koji smo poslali se desava u pozadini, dok ostatak koda nastavlja da se izvrsava. Ono sto moramo da uradimo ovde jeste da registrujemo callback funkciju na request objektu za load event. Mi smo sa send() metodom poslali request ka serveru medjutim ono sto on radi jeste da ce da emituje load event koji mi mozemo da slusamo i cim ti podaci dodju do nas pokrenuce se callback funkcija koju smo definisali u addEventListeneru.

request.addEventListener('load', function() {
    console.log(this.responseText);
})

...kao sto vidimo dosta veliki setup samo oko jednog poziva, ali tako je bilo nekad kada se koristio XMLHttpRequest. Danas moderni javascript ima bolje nacine za pravljenje AJAX poziva ka serveru. 


KAKO FUNKCIONISE WEB - ZAHTEVI I ODGOVORI (REQUESTS AND RESPONSE)
Kad god pokusamo da pristupimo web serveru, nas browser odnosno klijent, salje zahtev (request) serveru a onda ce server da posalje nazad odgovor  (response). Taj response sadrzi podatke koje smo mi zatrazili od web servera. 

https://restcountries.com/v3.1/name

... svaki url sadrzi u sebi http ili https sto je naziv za protokol koji ce da se koristi u konekciji. Zatim imamo domain ime (sto je uvom slucaju restcountries.com) i posle / imamo takozvani resource kom zelimo da pristupimo (/v3.1/name). Ovo domain ime (restcountries.com) nije prava adresa ka serveru kom zelimo da pristupimo, to je samo apstrakcija u obliku imena da bi nam bilo lakse da zapamtimo, to znaci da nam je potreban nacin da konvertujemo domain ime u pravu adresu servera. To se desava preko DNS-a. DNS je skracenica za Domain Name Server, to je specijalna vrsta servera, oni su kao telefonski imenik interneta. Prva stvar koja se desava kada pristupimo nekom web serveru jeste da nas browser napravi request (zahtev) ka tom DNS serveru i onda ovaj specijalni server uklapa web adresu tog url-a koji gadjamo sa serverovom pravom ip adresom. Sve se ovo desava preko vaseg internet provajdera. Nakon sto DNS server obradi domain ime i pretvori ga u pravu ip adresu servera, salje ga nazad browseru (klijentu). Tako da sada konacno mozemo da pozovemo server sa tom pravom ip adresom. Tako da bi prava adresa izgledala nesto ovako (https://104.27.142.889:443). Dakle adresa i dalje ima protokol (https) zatim ide ip adresa i na kraju port kom pristupamo na serveru. Ovaj port broj sluzi samo da bi identifikovali odredjeni servis koji se pokrece na serveru. Na taj port mozemo da gledamo kao na pod adresu (port number: default 443 for https, 80 for http). Sada kada imamo pravu ip adresu TCP socket connection je ustanovljen izmedju browsera (klijenta) i servera, tako da su ta dva sada konacno konektovana. Ova konekcija postoji sve vreme dok prebacimo sve podatke izmedju klijenta i servera. Sta je to zapravo TCP/IP? TCP je skracenica za transmisison control protocol (protokil kontrole prenosa), dok IP jeste skracenica za Internet Protocol. Zajedno cine komunikacione protokole koji definisu tacno kako podaci putuju preko weba. Oni su fundamentalni za kontrolni centar interneta. Oni postavljaju pravila kako se razmenjuju podaci preko interneta. Sada kada je ustanovljena veza izmedju naseg browsera (klijenta) i servera, konacno mozemo da posaljemo nas HTTP zahtev. HTTP je skracenica za hyper text transfer protocol. Taj http je jos jedan komunikacionin protokol. Komunikacioni protokol je sistem pravila koji dozvoljava dvema ili vise stranama da komuniciraju. U slucaju HTTP-a to je samo protokol koji dozvoljava klijentu i web serveru da komuniciraju. To funkcionise tako sto klijent salje request poruke a od servera dobija response poruke. Ta request poruka izgleda otprilike ovako: 

GET /v3.1/name/{name of the country}/PT HTTP/1.1

Host: www.google.com
User-Agent: Mozilla/5.0
Accept-Language: en-US

<BODY>

Pocetak poruke je najvazniji deo poruke. On sadrzi http metod koji se koristi u requestu, zatim request target i http verzija. Od svih http metoda najvaznije su GET za dobijanje podataka od servera, POST za slanje podataka od klijenta ka serveru, PUT/PATCH sluze za modifikovanje podataka na serveru i DELETE koji sluzi da obrisemo nasto neki podatak sa servera. Sto se tice request targeta (/v3.1/name/{name of the country}) ovde se kaze serveru da zelimo da pristupimo /v3.1/name/{name of country} resurs. Ako je ovaj target prazan onda bi pristupali root servera. 
Sledeci deo request poruke jeste request headers. U njemu se nalaze informacije o samom zahtevu (requestu). Npr koji browser koristimo, koje vreme saljemo request, koj jezik koristi user itd. I na kraju u slucaju da saljemo podatke serveru (post, put/patch) takodje ce postojati request body i taj body ce naravno da sadrzi podatke koje saljemo serveru, npr podatke iz html forme. 

Spomenuli smo gore da postoje HTTP i HTTPS protokoli. Glavna razlika izmedju njih je sto je HTTPS enkriptovan TLS/SSL, koji su zapravo samo jos protokola. U prevodu HTTPS protokol je sigurniji od HTTP-a. 

Sada kada je nas zahtev (request) dosao do servera, sada ce server obraditi nas request dok ne prikupi nase podatke ili web stranicu i poslace ih nazad ka klijentu. Kada ti podaci budu spremni poslace ih nazad preko http responsa. Ta http response poruka izgleda jako slicno kao http request poruka:

http response bi izgledao nesto ovako: 

HTTP/1.1 200 OK 

Date: Fri, 18 Jan 2022
Content-Type: text/html
Transfer-Encoding: chunked

<BODY>

Vrh ove poruke pored http verzije sadrzi status kod i status poruku. Oni se koriste da obaveste klijenta da li je zahtev bio uspesan ili ne. Npr 200 znaci OK, sve je u redu. Takodje jos jedan poznati status kod 404 koji predstavlja NOT FOUND. Response headers su informacije o odgovoru. Poslednja stvar u odgovoru jeste body, koji je prisutan u vecini odgovora (responsa). Uglavnom sadrze JSON podatke koji dolaze nazad sa API-a ili html web stranicu koju smo prethodno zatrazili. 

Mi smo u nasoj aplikaciji za sada napravili samo jedan request ka serveru ka restcountries.com i dobili jedan odgovor nazad. Medjutim ako pristupamo web stranici postojace mnogo zahteva i odgovora to je zato sto kada cinimo prvi zahtev sve sto dobijamo nazad jeste samo pocetni html fajl, zatim se taj html fajl skenira od strane browsera za sva sredstva koja su mu potrebna da bi napravio celu web stranicu, kao sto je javascript fajlovi, css fajlovi, sve slike koje mozda postoje na toj web stranici. Za svaki fajl ce postojati novi http request ka serveru. Naravno moguce je da se vise istovremenih poziva i odgovora desavaju u isto vreme. I na kraju kada svi fajlovi stignu do klijenta (browsera) celokupna stranica moze da bude ucitana na osnovu html-a, css-a i javescript-a.

Nesto vise o TCP/IP protokolima. Rekli smo da su to protokoli koji definisu kako podaci putuju preko weba. Zadatak TCP protokola jeste da razbije na vise komada zahteve i odgovore na hiljade malih komada. Jednom kada svi ti paketi stignu do svoje finalne destinacije, TCP protokol ce spojiti sve te pakete u originalni zahtev ili odgovor. Ovo je neophodno da bi svaki paket mogao da uzme drugu rutu kroz internet. Posto na ovaj nacin poruka dolazi do svoje destinacije najbrze moguce, sto ne bi bilo moguce ako posaljemo sve podatke kao jedan veliki paket. Sto se tice IP protokola, njegov zadatak jeste da da posalje i rutira ove sitne pakete kroz internet. On osigurava da stignu do destinacije do koje treba da dodju koristeci IP adrese na svakom paketu. 


PROMISES:
Do sada smo koristili XMLHttpRequest za pravljenje asinhronih odnosno AJAX poziva ka serveru, gde smo morali da konfigurisemo taj poziv sa .open() metodom, zatim da koristimo .send() metodu da posaljemo taj AJAX poziv i na kraju da regulisemo odgovor tako sto cemo da slusamo load event na tom zahtevu i da odredimo callback funkciju koja ce da se postara za odgovor servera. Medjutim postji dosta laksi nacin a to je da koristimo fetch() funkciju. Ta fetch funkcija odmah vraca promise. Medjutim sta je to promise? Formalna definicija promisa jeste da je to objekat koji se koristi kao neki cuvar mesta za buduci rezultat asinhrone operacije. Manje formalna definicija bi bila da je promis kontejner za asinhrono isporucenu vrednost, ili jednostavno promise je kontejner za buducu vrednost. Odlican primer za buducu vrednost jeste odgovor AJAX poziva. Kada startujemo AJAX poziv u tom trenutku jos uvek ne postoji vrednost, ali znamo da ce u nekom trenutku u buducnosti ta vrednost doci do nas, tako da mozemo da koristimo promise da regulisemo ovu buducu vrednost. E sad koja je prednost koriscenja promisa? Zapravo postoje dva razloga za koriscenja promisa. Prvo koristeci promise vise ne moramo da se oslanjamo na evente i callback funkcije koje ce da regulisu asinhronu operaciju. Drugi razlog zasto su promisi bolji jeste da mozemo da ih vezujemo jedan za drugim i tako da imamo vise asinhronih operacija bez da gnezdimo jednu callback funkciju unutar druge i tako pravimo callback hell. Promisi su predstavljeni 2015e godine sa dolazkom ES6 standarda. Posto promisi rade sa asinhronim operacijama oni su osetljivi na vreme, dakle menjaju se vremenom. To znaci da promis moze da bude u vise stanja! To se zove zivotni put (life cicle) promisa. Na samom pocetku kazemo da je promise u pending fazi. Ovo je slucaj kada vrednost od asinhronog poziva jos uvek nije dostpuna. U ovom trenutku asinhroni zadatak jos uvek radi svoj poso u pozadini. Kada se taj asinhroni task konacno zavrsi kazemo da je promise settled. E sad postoje dva razlicita tipa settled promisa. Prvi je fullfilled (ispunjen) promis a drugi je rejected (odbijen) promise. Ispunjen (fullfilled) promis je promis koji je uspesno rezultirao u vrednost koju smo ocekivali. Npr ako koristimo promis da potrazimo podtake od servera, fullfilled (ispunjen) promis ce uspesno dostaviti te podatke do nas i sada su dostpune da koristimo te podatke koje smo trazili od servera. Na drugu stranu rejected (odbijeni) promis znaci da se desila neka greska tokom asinhrone operacije. Ako opet pogledamo primer gde zahtevamo neke podatke od servera, greska bi bila kada je user offline i ne moze da se konektuje na api server. Naravno mi u kodu koristeci fetch funckiju mozemo da regulisemo i fullfilled (ispunjeni) promis kao i rejected (odbijeni) promis. Bitna stvar vezana za promise jeste da se promis uredjuje (bude settled) jednom. Odatle njegovo stanje ostaje tako zauvek, nece se vise menjati. Dakle promis je ili fullfilled ili rejected i nemoguce je da promenimo to stanje. Ova dva stanja settled promisa su jako bitna jer nam pomazu da konzumiramo promis. Mi konzumiramo promis kada imamo promis, npr promis koji vraca fetch funkcija kada dobavljamo neke podatke od servera. Da bi promis uopste postojao, on mora prvo da bude izgradjen, mora da bude kreiran. U slucaju fetch API-a, upravo fetch funkcija gradi taj promis i vraca ga nama da ga konzumiramo. U slucaju fetch funkcije mi nemoramo da pravimo sami promis vec ce ga za nas izgraditi fetch funkcija. U vecini slucaja mi cemo konzumirati promise, medjutim naravno da mozemo i sami da napravimo promis.  

KONZUMIRANJE PROMISA:
Kao sto smo rekli kada pozovemo fetch funkciju ona ce odmah vratiti promis. Medjutim taj promis kao sto smo rekli bice u pending fazi, odnosno taj asinhroni zadatak jos uvek traje u pozadini. U nekom trenutku taj promis bice settled. Kao sto znamo taj settled promis ima dva stanja. Prvi je u slucaju da je promis uspesan (fullfilled) a drugi je da je odbijen (rejected). Da pretpostavimo da je promis za sada bio uspesan i da mi imamo dostupnu vrednost koja dolazi od servera sa kojom mozemo da radimo, da bi rukovali tim podacima odnosno fullfilled stanjem promisa mozemo da koristmo then() metodu. Ta then() metoda bice dostpuna na svim promisima. 

fetch(`https://restcountries.com/v3.1/name/${country}`).then(function(response) {
    return response.json()
}).then(function(data) {
    console.log(data)
})

...ako znamo da fetch funkcija vraca promis onda mozemo da nadovezemo metodu then() posto je ona dostupna na svemu sto vraca promis. 
Unutar then() metode moramo da prosledimo callback funkciju koja zelimo da se izvrsi cim promis bude fulfilled (ispunjen). Ova callback funkcija koju odredjujemo unutar then() metode primice jedan argument kada je bude pozvao js i taj argument je rezultat tog fulfilled promisa. Ovo je nacin kako se nosimo sa ispunjenim promisom. Odgovor servera koji zapravo trazimo bice unutar tog response argumenta pod svojstvom body. Medjutim mi jos uvek ne mozemo da radimo s tim podacima, tj ne mozemo da ih procitamo. Da bi mogli da procitamo te podatke ono sto moramo da uradimo prvo jeste da pozovemo .json() metodu na tom responsu. .json() metoda bice dostpuna na svim responsima fetch funkcije. E sad problem ovde jeste sto .json() metoda takodje asinhrona funkcija. To znaci da vraca novi promis. Ono sto moramo da uradimo jeste da vratimo novi promis iz then() metode (vidi primer gore). Ako sada .then() metoda vraca novi promis to znaci da moramo da ga regulisemo. To radimo opet sa .then() metodom, jer kao sto znamo .then() metoda je dostpuna na svemu sto vraca promis. Prica je opet ista, u toj drugoj .then() metodi moramo da definisemo callback funkciju koja ce da primi argument, koji ce zapravo da predstavlja podatke koje ocekujemo od servera. 
Ono sto cini promise jako dobrim za koriscenje jeste sto mozemo da ih nadovezujemo jedan za drugim. Gore u primeru se vec vidi primer tog nadovezivanja. Ono sto je bitno da razumemo jeste da .then() metoda UVEK vraca promis, bez obzira na to da li mi vratili nesto iz nje ili ne. Ali ako ipak vratimo neku vrednosti iz .then() metode onda ce ta vrednost da postane fullfillment (ispunjena) vrednost od vracenog promisa. 

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => response.json())
    .then((data) => {
      const neighbor = data[0].borders?.[0];

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json())
    .then((data) => renderCountry(data[0], "neighbor"));
}

getCountryData("finland");

U ovom slucaju prvo pozivamo prvu drzavu, cim dobijemo njene podatke, nalazimo jednu od border drzava i pravimo novi zahtev ka serveru sa tom borderom drzavom. Tako da ce sada js uvek izvrsiti poziv prve drzave pa tek onda poziv druge drzave. U drugoj .then() metodi izvukli smo neighbor drzavu i napravili novi fetch poziv, koji vracamo iz te druge .then() metode sto znaci da ona sada vraca promis koji mozemo dalje da regulisemo. 
Naravno da ovde mozemo da nastavimo niz i da vezujemo dalje promise i da ih regulisemo sa .then() metodama!


HANDLING REJECTED PROMISES:
Do sada smo pretpostavili da je sve u redu sa nasim promisom, medjutim kao sto znamo pored ispunjenog promisa, posotji i rejected odnosno odbijeni promis. Ukoliko dodje do odbijenog promisa to takodje moramo da resimo u nasem kodu. Dakle promis u kom se desila greska jeste rejected (odbijeni) promis. Kako da se nosimo sa tim odbijenim promisom? 
Jedini put kada ce promis da bude odbijen u slucaju fetch funckije jeste kada korisnik izbubi internet konekciju!
Postoje dva nacina da se regulisu odbijeni (rejected) promisi. Prvi nacin jeste da se prosledi druga callback funkcija unutar .then() metode. Tako da ce prva callback funkcija unutar .then() metode da bude pozvana kada je promis fullfilled (uspesan), a druga callback funkcija bi bila pozvana ukoliko bi doslo do greske i nas promis bude odbijen (rejected). Ta druga callback funkcija koja ce da regulise odbijeni promis prima jedan argument a to je zapravo sam error koji se desio. Na taj nacin mozemo da uhvatimo error unutar naseg promisa i da ga prikazemo korisniku. Ono sto je bitno da razumemo ukoliko se desila neka greska prilikom fetchovanja podataka i nas promis bude odbijen, mi hvatamo tu gresku u drugoj callback funkciji .then() metode i tu prestaje nase nadovezivanja .then() metodama. 

fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => response.json(), (error) => alert(error))

...medjutim sta ako se greska nije desila u ovom prvom delu fetch funckije nego negde kasnije u kodu, kasnije u nasem povezivanju .then() metoda? Sta ako je ovaj prvi promis bio ispunjen a da promis druge fetch funkcije (koja poziva drugu drzavu) bude odbijen usled neke greske? Tada bi morali da regulisemo gresku u .then() metodi posle tog drugog fetch poziva. 

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(
      (response) => response.json(),
      (err) => alert(err)
    )
    .then((data) => {
      const neighbor = data[0].borders?.[0];

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json(), (error) => alert(error))  // i ovde smo morali da definisemo drugu callback funkciju unutar .then() metode kako bi regulisali odbijeni
    .then((data) => renderCountry(data[0], "neighbour"));             promis usled druge fetch funkcije koja poziva neighbor drzavu. 
}

Ovo postaje dosta naporno, da regulisemo greske na vise mesta. Na svu srecu postoji dosta bolje resenje za hvatanje i resavanje gresaka usled odbijenog promisa. Zapravo postoji nacin gde mozemo da regulismo error na jednom mestu. Umesto svih ovi callback funckija koje smo definisali kao druge argumente .then() metoda, mozemo da pozovemo .catch() funkciju i ona ce da uhvati gresku za nas, gde god da se desila u ovom nizu .then() metoda! Toj catch() funkciji takodje prosledimo callback funkciju koja ce da bude pozvana ukoliko dodje do greske bilo gde u nasem lancu .then() metoda. Ta callback funkcija ce da primi error objekat kad argument, da ne bi prikazivali ceo error objekat, taj error objekat u sebi ima message svojstvo koje mozemo da iskoristimo da prikazemo samo poruku a ne ceo error objekat.  

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => response.json())
    .then((data) => {
      const neighbor = data[0].borders?.[0];

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json())
    .then((data) => renderCountry(data[0], "neighbour"))
    .catch((error) => alert(error)); 
}

...ova catch() metoda na kraju niza ce bukvalno uhvatiti bilo koju gresku koja se desilo bilo gde u ovom celom nizu promisa, bez obzira gde se greska desila. Cim neki promis bude obijen on biva prosledjen do kraja odnosno do catch() funkcije. 

Na kraju postoji jos jedna metoda koju bi trebali da napomenemo a koja je isto dostpuna na svim promisima. Dakle pored .then() i .catch() metode postoji i treca koja se zove .finally() metoda. Ta finally() metoda bi uvek trebala da ide na kraju lanca posle svih .then() metoda kao i posle .catch() metode. Finally() metoda ce raditi zato sto i .catch() metoda vraca promis, sto nam govori da finally() metodu mozemo da pozovemo samo na necemu sto vraca promis. Finally() metodi isto tako definisemo callback funkijcu i ona ce uvek da bude pozvana ne vezano za to kakav je nas promis, da li je uspesan ili odbijen. Dakle .finally() metode ce uvek da bude pozvana! Za razliku od .then() metode koja ce da se pozove jedino ako je nas promis uspesan (fullfilled) a .catch() ce da bude pozvana samo ukoliko se desi neka greska. Finally metodu mozemo da koristimo ako znamo da nesto treba da se desi nevezano za to da li je nas promis bio uspesan ili ne. Npr to moze da bude da sakrijemo load spiner ukolko postoji na nasoj stranici. Dakle ako prikazemo neki spiner kada krenemo da fetcujemo podatke sa servera i onda na kraju da ga sakrijemo kada se operacija zavrsi. A to ce se desiti ne vezano za to da li je nas promis bio uspesan ili ne!

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => response.json())
    .then((data) => {
      const neighbor = data[0].borders?.[0];

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json())
    .then((data) => renderCountry(data[0], "neighbour"))
    .catch((error) => {
      renderError(`Something went wrong 💥💥💥. ${error.message}`);
    })
    .finally(() => {
      countriesContainer.style.opacity = 1;
    });
}

btn.addEventListener("click", function () {
  getCountryData("italy");
});


THROWING ERROR MANUALLY:
Gore smo prikazali kako da uhvatimo gresku ukolko promis bude odbijen. Medjutim dobra aplikacija ima i dobro resene greske koje mogu da nastanu usled njenog koriscenja. Sta ako u gornjem primeru pozovemo getCountryData('blabla') sa nekom zemljom koja ne postoji? Nasa .catch() funkcija ce uhvatiti gresku ali ona nece biti precizno odredjena. Kao sto smo rekli fetch funkcija vraca gresku samo ukolko korisnik nije konektovan na internet. Ukolko je greska kao u opisanom slucaju 404 (not found) jer ne mozemo da nadjemo drzavu 'blabla' to moramo sami da regulisemo i da napravimo nasu gresku za to!

Ako zelimo da sami napravimo gresku to mozemo da ucinimo preko konstruktor funkcije ovako:

throw new Error('ovde prosledjujemo message svojstvo');

...new Error() je pozivanje konstruktor funkcije dok 'throw' kljucna rec odmah prekida izvrsavanje trenutne funkcije bas kao sto i return radi. Efekat kreiranja greske na ovaj nacin jeste da ce promis odmah da bude odbijen (reject). To znaci da ce trenutni blok .then() bloka odmah da bude prekinut i taj .then() ce da vrati odbijeni promis koji ce da bude uhvacen u catch bloku.

SVAKA GRESKA UZROKOVACE DA PROMIS BUDE ODBIJEN (REJECT)!!!

fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => {
      if (!response.ok) {
        throw new Error('Country not found')  // ako smo throw new Error() definisali ovde u ovoj then metodi ona ce odmah vratiti odbijeni promis. Zatim ce taj odbijen promis
      }                                          odmah da bude uhvacen u catch funkciji. 

      return response.json();
    }).catch(error => {
      alert(error.message)
    })

Ta poruka koju smo prosledili kada smo konstruisali nas Error u ovom slucaju 'Country not found' bice prosledjena sve do catch bloka u njegovom parametru koji prima pod svojstvom error.message.

Medjutim sta ako se greska nije desila u prvom fetch pozivu. Sta ako je tu sve u redu a tek u drugom fetch pozivu za neighbor drzavu postoji greska. To cemo onda handlovati u trecoj .then() metodi odmah ispod .then() metode koja vraca fetch() poziv za neighbor drzavu.

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => {
      if (!response.ok) {
        throw new Error(`Country not found ${response.status}`);
      }

      return response.json();
    })
    .then((data) => {
      const neighbor = 'blabla';

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json())
    .then((data) => renderCountry(data[0], "neighbour"))
    .catch((error) => {
      renderError(`Something went wrong 💥💥💥. ${error.message}`);
    })
    .finally(() => {
      countriesContainer.style.opacity = 1;
    });
}

...jos jedno mesto koje bi koristili da handlujemo gresku manuelno jeste ukolko ne postoji neibhour drzava (npr za ostrva). Mogli bi kod uslova:

if (!neighbor) return 

...umesto ovog mogli bi da napisemo nesto ovako:

if (!neighbor) {
  throw new Error(`There is no neibhour country for ${country}`)
}

...ovo bi predstavljalo mnogo jasniju gresku za korisnika.


ASYNCHRONOUS BEHIND THE SCENES: THE EVENT LOOP:
Da bi krenuli sa ovom lekcijom moramo da se podsetimo javascript runtime-a. Dakle javascript runtime je prakticno kontejner koji ukljucuje sve razlicite delove koji su potrebni da bi se izvrsio javascript kod. Srce svakog javascript runtime-a jeste engine. Tu se zapravo kod izvrsava i gde se objekti smestaju u memoriji. Ono sto moramo opet da napomenemo jeste da javascript ima samo jedan thread izvrsavanja. To u prevodu znaci da moze da radi samo jednu stvar istvoremeno. Ne postoji opcija za multitasking! Drugi jezici poput jave mogu da izvrsavaju vise delova koda istvoremeno. Dalje unutar runtime-a imamo web api okruzenje. To su neki api-i koji su dostpuni enginu ali koji zapravo nisu deo samog javascript jezika (dom api, timers api, fetch api, geoloction api itd...). Sledeci deo javascript runtime-a jeste callback queue struktura podataka, koji sadrzi sve callback funkcije spremne za izvrsavanje (dakle callback funkcije koje su zakacene na neki event koji se desio). Na kraju kada se callstack isprazni event loop uzima callback funkcije iz callback queue-a i prebacuje ih u callstack kako bi mogle da se izvrse. Taj event loop omogucava aisnhrono ponasanje u javascript-u. To je razlog zasto mozemo da imamo non-blocking concurency model u javascriptu sto je samo fensi termin za to kako se jezik snalazi kada postoje vise stvari odjednom koje treba izvrsiti. Kako taj concurency model zapravo radi? I zasto je taj spomenuti event loop toliko bitan?

Kao sto znamo do sada javascript engine je zamisljen tako da se izvrsava samo u jednom thread-u. Ali ako postoji samo jedan thread izvrsvanja u enginu kako se onda asinhroni kod izvrsava neblokirajuci ostatak koda? 

el = document.querySelector('img');
el.src = 'dog.jpg';
el.addEventListener('load', () => {
  el.classList.add('fadeIn');
});

fetch('https://someurl.com/api')
  .then(res => console.log(res));

// more code...

U prvoj liniji koda mi hvatamo img element, dakle pravi se execution context izvrsava se i on se sklanja iz callstack-a. U sledecoj liniji koda mi podesavamo src atribut toj slici koju smo selektovali u prvoj liniji koda. Kao sto znamo od ranije to ce poceti da ucitava sliku u pozadini (asinhrono). Sta je ta misteriozna pozadina u kojoj se izvrsava asinhroni kod? Kao sto znamo sve sto je vezano za DOM nije vezano za sam javascript jezik vec je deo web api-a. Sve vezano za DOM ce se pokrenuti u web api-u. Isto vazi i za timer-e, ajax pozive...bukvalno za sve asinhrone zadatake. SVI ASINHRONI ZADACI CE SE IZVRSAVATI U OKRUZENJU WEB API-A UNUTAR BROWSERA (posto ih upravo browser obezbedjuje javascript enginu). Kada bi se slika i njen src ucitavali sinhrono to bi se onda izvrsavalo u callstack-u js engina, blokirajuci ostatak koda. Ali kao sto znamo to bi bilo jako lose i zato je ucitavanje slike u javascriptu primenjeno na asinhroni nacin. Dakle ne desava se u callstack-u, odnosno u tom jednom threadu izvrsavanja, vec u orkuzenju web api-a (koji su deo run time-a). Ukoliko zelimo da uradimo nesto kada se ta slika ucita onda moramo da slusamo load event. To je upravo ono sto radimo na trecoj liniji koda (iznad). Dakle tu smo prikljucili event listener toj slici i osluskujemo load event te slike, ali isto tako prosledjujemo i call back funkciju. U ovom slucaju mi registrujemo tu callback funkciju unutar web api okruzenja upravo tamo gde se slika (asinhrono) ucitava i ta callback funkcija ce ostati tu (u web api okruzenju) sve dok se slika ne ucita. Posle toga mi pravimo AJAX poziv ka serveru uz pomoc fetch funkcije. Kao sto znamo i ta operacija ce se izvrsavati asinhrono u delu web api okruzenja. Na kraju koristimo .then() metodu da bi resili promis koji vraca fetch funkcija. I ovo ce registrovati callback unutar okruzenja web api-a i reagovace za buducu resenu radnju promisa. Taj callback (res => console.log(res)) je asociran sa promisom koji fetchuje podatke sa servera. Sa ovom poslednjom linijom smo izvrsili sav top level kod, dakle kod koji nije ni u jednoj callback funkciji. Za sada imamo sliku koja se ucitava kao i fetchovanje nekih podataka u delu web api-a koji se desvaju asinhrono. 
Recimo da je slika zavrsila uctaivanje, to znaci da se emitovao load event na toj slici. Ono sto se desava sledece jeste da ce callback za ovaj event da predje iz web api okruzenja unutar callback queue strukture podataka (taj callback queue je prakticno neka uredjena lista svih callback funkcija koje cekaju u redu da se izvrse). U trenutnom primeru mi u callback queue strukturi nemamo drugih callback funkcija, sem ove koju smo registrovali na load event kada je slika zavrsila asinhrono ucitavanje. Naravno da imamo drugih callback funkcija ona bi dosla na kraj ovog reda posle vec postojecih callback funkcija unutar callback queue-a i cekala bi svoj red za izvrsavanje. Medjutim zamislite da postavite timer na 5 sekundi i posle tih 5 sekundi timer-ova callback funkcija ce biti stavljena unutar callback queue-a. Zamislimo da je u toj callback queue vec bilo drugih callback funkcija koje su cekale svoj red izvrsavanja. Pretpostavimo isto da je svim tim callback funkciijama (koje su se nalazile pre callback funkcije timer funkcije) trebala 1 sekunda da se izvrse pre nego sto na red dodje callback funkcija timera. To znaci da bi se nasa callback funkcija iz timera pokrenula tek posle 6 sekundi, dakle ne posle 5 kao sto smo definisali unutar timer funkcije. Dakle tih 6 sekundi su 5 sekundi koje smo definisali timer funkciji i plus 1 sekunda koja bila potreba da se pokrenu sve prethodne callback funkcije unutar callback queue-a koje su cekale svoj red izvrsavanja. To znaci da vreme koje definisemo nasim timerima nije garantovana. To vreme nam samo garantuje da se callback funkcija nece pokrenutni pre tih 5 sekundi. Ali je moguce da se desi da se pokrene nakon tih pet sekundi i vise. Sve zavisi od stanja callback queue-a i koliko je vec pun sa callback funkcijama koje cekaju svoj red izvrsavanja. Taj callback queue ce sadrzati sve callback funkcije koje dolaze od dom evenata, kao sto su click, keypresses i ostalo. Naucili smo ranije da dom eventi nisu asinhroni, ali takodje koriste callback queue da bi zakacile svoje callback funkcije. 
Sta radi taj event loop? Dakle on gleda unutar callstack-a da li je prazan ili ne. Ako jeste prazan onda ce uzeti prvu callback funkciju unutar callback queue-a i prebacice je unutar callstack-a kako bi mogla da se izvrsi. Dakle taj event loop je zato toliko bitan, jer je on glavna veza izmedju callback queue-a strukture podataka i callstack-a gde se zapravo izvrsava sav kod. Ako nastavimo nas primer odozgo videcemo da u web api okruzenju imamo jos jedan asinhroni zadatak koji se izvrsava, a to je fetch poziv, tacnije registvorana callback funkcija .then() metode, koja ceka da taj asinhroni zadatak bude zavrsen i da onda callback funkcija resi taj promis. Medjutim sa promisima je malo drugacije. Recimo da su podaci konacno dosli sa servera i da je fetch funkcija zavrsila. Callback funkcije koje imaju veze sa promisima (kakav je ova unutar .then metode) NE IDU UNUTAR CALLBACK QUEUE STRUKTURE PODATAKA. SVE CALLBACK FUNCKIJE KOJE IMAJU VEZE SA PROMISIMA IDU U STRUKTURU PODATAKA KOJA SE NAZIVA MICROTASKS QUEUE. Ono sto je specijalno za MICROTASKS QUEUE jeste sto ima prioritet nad CALLBACK QUEUE. To znaci da ce event loop prvo da prebaci sve callback funkcije iz MICROTASKS QUEUE-a u callstack da se izvrse pa tek zatim ce poceti da prebacuje callback funkcije iz CALLBACK QUEUE-a. Ako jedan microtasks napravi doda jos neki microtasks onda ce taj novi microtasks da bude izvrsen pre bilo koje callback funkcije unutar CALLBACK QUEUE-a. 


PRAVLJENJE PROMISA:
Posto znamo da su promisi samo objekti mozemo da ih napravimo kao i sve druge uz pomoc konstruktor funkcije new Promise(). Taj promis konstruktor uzima tacno jedan argument. To je takozvana executor funkcija. Tako da u tom pozivu konstruktor funkcije prosledjujemo tu executor funkciju sto izgleda ovako: 

new Promise(function() {

})

...cim se Promis konstruktor pokrene on ce automatski odmah izvrsiti ovu executor funkciju koju smo prosledili kao argument. Kada bude krenuo da je izvrsava uradice to tako sto ce joj proslediti dva argumenta. Ta dva argumenta su resolve i reject funkcije. Dakle kod bi sad izgledao ovako:

new Promise(function(resolve, reject) {
  // ova executor funkcija ce da sadrzi asinhrono ponasanje koje cemo mi da resimo sa promisom. Ova executor funkcija na kraju treba da proizvede resolved value. Vrednost koja ce da bude buduca vrednost promisa. 
})

...ovaj promis mozemo da uskladistimo u neku promenljivu, bas kao i fetch funkcija koja vraca promis tako ce i poziv konstruktor funkcije da vrati promis.

const lotteryPromis = new Promise(function(resolve, reject) {
  // u ovoj prvoj situaciji recimo da dobijamo na lutriji. To ce za nas da znaci fullfilled promis. Da bi postavili promis da bude fullfilled odnosno ispunjen koristimo resolve() funkciju koju prima executor funkcija kao prvi argument. Pozivanje resolve() funkcije kao sto mi radimo ovako ce oznaciti ovaj promis kao fullfilled. Unutar te resolve() funkcije prosledjujemo ispunjenu (fulfilled vrednost) promisa kako bi kasnije mogli da je konzumiramo sa .then() metodom. Dakle jos jednom, koju god vrednost da prosledimo resolve() funkciji ta vrednost ce da bude dostupna unutar .then() metodi kao fulfilled vrednost promisa. 

  if (Math.random() >= 0.5) {
    resolve('You win the lottery')
  } else {
    // dok s druge strane ako zelimo da promis oznacimo kao odbijen odnosno rejected promis onda koristimo reject() metodu. Unutar te reject() metode prosledjujemo error poruku koju cemo kasnije da uhvatimo unutar .catch() metode. 

    reject('You lost your money')
  }
})

Kada pravimo promis uvek moramo da se postaramo da on zavrsi u jednoj od ove dve funkcije ili da bude resolve() fulfilled promis ili da bude reject() odbijeni promis!

lotteryPromis ce da bude promenljiva koja ce da sadrzi promis nad kojoj mozemo da pozovemo .then() metodu da bi konzumirali taj promis. Ta .then() metoda zatim prima kao argument kroz callback funkciju resolved vrednost (fulfilled vrednost). 

lotteryPromis.then(res => console.log(res)).catch(err => console.log(err))

U ovom slucaju res ce biti upravo onaj string koji smo prosledili resolve() funkciji dakle "You win the lottery", dok ce err unutar catch funkcije da bude upravo string koji smo prosledili reject() funkcji, dakle 'You lost your money'.


KONZUMIRANJE PROMISA SA ASYNC_AWAIT:
Sa dolazkom Ecma Script 2017 verzije postoji jos laksi nacin da konzumiramo promise. To je naravno sintaksa async_await. Kako se koristi? Krecemo od toga sto pravimo funkciju, ali to nece biti obicna funkcija vec asinhrona funkcija:

const whereAmI = async function(country) {

}

...asinhronu funkciju pravimo tako sto joj dodeljujemo async kljucnu rec ispred function kljucne reci. To je sada asinhrona funkcija, dakle funkcija koja ce se pokretati u pozadini dok izvrsava kod koji se nalazi u njoj. Kada ova funkcija zavrsi sa izvrsavanjem koda u njoj ona automatski vraca promis! Ono sto je bitno jeste da sada unutar te funkcije mozemo da koristmo await kljucnu rec. Uz pomoc te await kljucne reci mi mozemo da sacekamo promis. Ovako:

const whereAmI = async function(country) {
  await = fetch('someurl');
}

...kao sto vidimo mi sa await mozemo da cekamo promis koji vraca fetch funkcija! Await ce stopirati izvrsavanje funkcije sve dok fetch funkcija ne zavrsi i ne vrati promis, u prevodu dok podaci ne dodju do nas. To sto ce stopirati funkciju nije lose jer je to asinhrona funkcija sada i izvrsavace se u pozadini, dakle nece blokirati onaj glavni tread izvrsavanja unutar callstack-a. I to je jos jedna jako dobar stvar kod async_await, sto cini nas kod da izgleda sinhrono dok je zapravo asinhrona operacija i izvrsava se u pozadini (odnosno u delu web api-a). Cim fetch funkcija zavrsi i bude vratila promis, mi to mozemo da uskladistimo unutar neke promenljive. 

const whereAmI = async function(country) {
  const response = await fetch('someurl');
}

Ukoliko bi pokrenuli ovaj kod ispod:

whereAmI('serbia');
console.log('first')

Konzola u kojoj pise 'first' bi se prva izvrsila jer je to u glavnom tredu callstack-a dok je whereAmI funkcija asinhrona sto zaci da ce se izvrsavati u pozadini u okruzenju web api-a i tek kada bude gotova, bice prebacena unutar microtasks queue odakle ce je event loop premestiti u callstack kad bude bio prazan i tek ce se tad izvrsiti. 

Taj async_await je samo apstrakcija preko obicne .then() metode koje koristimo nad promisima. Naravno u pozadini iza async_await mi i dalje koristimo promise! S tim sto sa await-om koristimo drugaciji nacin da konzumiramo te promise. 

const res = await fetch('someurl');
console.log(res)

ovo je isto kao da smo napisali 

fetch('someurl').then(res => console.log(res))

Sledeci korak bas kao kod obicnih fetch i then metoda moramo da primenimo .json() metodu nad fulfulled promisom da bi ocitali lepo te podatke koje nam salje server. Dakle ovako:

const whereAmI = async function(country) {
  const response = await fetch('someurl');
  // kao sto primecujemo ovde opet moramo da koristimo await kljucnu rec jer .json() metoda takodje vraca promis koji mora da bude sacekan, sto upravo to radi await.
  const data = await response.json();

  // sada ovo izgleda mnogo lakse jer mozemo da sacekamo (await) rezultate i da ih odmah uskladistimo u promenljivu. 
}

Kao sto vidimo kljucne reci async_await cine kod dosta citiljivijim i takodje nam pomazu da izbegnemo sve one callback funkcije koje smo koristili kod .then() metoda!
Pitanje koje se postavlja kako resavamo greske kada koristimo async_await sintaksu? To radimo uz pomoc try_catch statement!


ERROR HANDLING WITH TRY_CATCH:
try_catch statement se koristi u regularnom javascriptu takodje, dakle postoji u jeziku vrv od pocetka postojanja javescripta. try_catch sintaksa nema nista sa asinhronim javascritom ali takodje mozemo da je koristimo za hvatanje gresaka u asinhronim funkcijama. 

try {
  let y = 3;
  const x = 2;
  x = 1;
} catch(error) {
  // now we can do something with this error
  alert(err.message)
}

...catch blok ce sada imati pristup gresci koja se desila u try bloku! Tako da sada mozemo da koristimo tu gresku i da radimo nesto s njom. Ukoliko nije bilo gresaka unutar try bloka onda ce se taj blok izvristi i kod uopste nece uci u catch blok! Ovo je bio primer cisto da pokazemo da try_catch radi sa obicnim kodom. Sada sledi primer sa async_await sintaktom.

const whereAmI = async function() {
  try {
    const pos = await fetch('some url');
    const data = await pos.json();
    
    const res2 = await fetch('some other url');
    const data2 = await res2.json();

    renderCountry(data2[0])
  } catch (error) {
    console.log(`Something went wrong ${error.message}`)
  }
}

Dakle koja god greska da se desi u ovom try bloku mi to hvatamo u catch bloku bas kao sto smo hvatali sa .catch() metodom kod obicne fetch funkcije. 

Ukoliko bi pokusali da vratimo nesto iz ove asinhrone funkcije ovako:

const whereAmI = async function() {
  try {
    const pos = await fetch('some url');
    const data = await pos.json();
    
    const res2 = await fetch('some other url');
    const data2 = await res2.json();

    renderCountry(data2[0])

    return 'Returned value from async function'
  } catch (error) {
    console.log(`Something went wrong ${error.message}`)
  }
}

console.log('I will run first')
const sentence = whereAmI();
console.log(sentence) // Promise<pending>
console.log('Finished')

...u ovom delu koda gde smo pokusali da uskladistimo vrednost koju vraca asinhrona funkcija whereAmI() javascript jos uvek ne zna sta vraca ta asinhrona funkcija jer se ona izvrisava u pozadini, ali ako znamo da ona vraca promis to ujedno znaci da ce sentence promenljiva u sebi uskladistiti promis koji se nalazi u pending fazi, dakle jos uvek nije zavrsio svoj u pozadini. Ono sto je takodje bitno da razumemo jeste da ono sto smo vratili iz asinhrone funkcije, tacnije iz try bloka ovaj string 'Returned value from async function' to ce postati fulfilled vrednost tog promisa koji vraca whereAmI asinhrona funkcija, naravno kada zavrsi sa izvrzavanjem. 
Sada se postavlja pitanje ako ne mozemo da vratimo vrednost iz asinhrone funkcije kako onda uzimamo i koristimo tu vrednost iz nje? Pa prosto, ako znamo da asinhrona funkcijaj vraca promis, mozemo da joj nadovezemo .then() metodu jer kao sto znamo .then() metoda bice dostpuna na svemu sto vraca promis. Dakle ovako:

whereAmI().then(res => console.log(res)) // res argument unutar callback funkcije then() metode bice upravo fulfilled vrednost promisa koji vraca whereAmI asinhrona funkcija.

...na ovaj nacin smo uspesno vratili vrednost iz funkcije.

U ovom trenutku ukoliko se desi neka greska u try bloku (recimo da url prosledjen fetch funkciji bude los) javascript ce i dalje da prikaze u konzoli rezultat .then() metode tacnije prikazace undefined. To znaci da se izvirsila callback funkcija .then() metode, sto opet znaci da se pozvala .then() metoda, sto opet znaci da se pokrenula whereAmI() funkcija i da je vratila promis. To bi se desilo cak iako bi nadovezali .catch() metodu nad .then() metodom. Ukoliko bi zeleli da uhvatimo gresku i da je prikazemo morali bi da opet bacimo gresku unutar catch bloka asinhrone funkcije, ovako:

const whereAmI = async function() {
  try {
    const pos = await fetch('some url');
    const data = await pos.json();
    
    const res2 = await fetch('some other url');
    const data2 = await res2.json();

    renderCountry(data2[0])

    return 'Returned value from async function'
  } catch (error) {
    console.log(`Something went wrong ${error.message}`)
    
    // Rejected promise returned from async function
    return err;      // ovako rethrowujemo gresku koju sada mozemo da uhvatimo u .catch() funkciji ako nadovezujemo nad whereAmI() funkciju!
  }
}

whereAmI().then(res => console.log(res)).catch(error => console.log(error))

Slozicemo se da je ovo mixovanje nove i stare sintakse, naravno da sve ovo mozemo da odradimo samo preko async funckije. Ako znamo da whereAmI() vraca promis, mozemo da ga tretiramo kao i svaki drugi promis, tj sa await. 

Pisemo immediately invoked function expression:

(async function() {
  try {
    const stringResults = await whereAmI()
    console.log(stringResults)
  } catch(err) {
    console.log(err)
  } finally() {
    console.log('3: Finished getting results')
  }

  // console.log('3: Finished getting results') 

  // cak ne moramo da koristimo ni finally metodu, mogli smo ovaj poslednji console.log da ostavimo na dnu funkcije i on bi se svakako izvrsio, dakle van try i van catch bloka!
})()


RUNNING PROMISES IN PARALLEL:
