ASYNCHRONOUS JAVASCRIPT PROMISES ASYNC_AWAIT AND AJAX

Da bi razumeli sta je to asinhroni kod, prvo moramo da razumemo sta je to sinhroni kod. Vecina koda koju smo do sada pisali jeste bila sinhroni kod. Sinhrono prosto znaci da se kod izvrsava liniju po liniju, tacno onako kako smo definisali u kodu. U primeru ispod, kako prva linija koda krene sa izvrsavanjem, ona ce se izvrisiti u execution threadu (to je deo execution contexta koji inace izvrsava kod u kompijuterskom procesoru). Zatim je sledeca linija koda izvrsena, odmah potom treca linija (alert). Svaka linija koda uvek ceka da prethodna linija zavrsi izvrsavanje. Ovo moze da stvori probleme, kada jedna linija koda zahteva puno vremena da se izvrsi. Kao sto imamo u primeru na trecoj liniji alert('Text set') imamo ovaj alert statement koji kreira alert prozor. Kao sto znamo do sada ovaj alert prozor blokira dalje izvrsavanje koda. Nista nece funkcionisati na stranici sve dok ne stisnemo OK button u alert prozoru. Tek ce tada kod nastaviti sa izvrsavanjem. Tako da je ovaj alert statement vrlo dobar primer nekog procesa koji traje duze vreme i koji samim tim blokira izvrsavanje ostatka koda. 

const p = document.querySelector('.p');
p.textContent = 'My name is Jonas!';
alert('Text set');
p.style.color = 'red';

Ovim smo pokazali zato sto je sinhroni kod los. Blokiranje daljeg izvrsavanja koda nije dobro po UX. Sinhroni kod je sasvim okej u vecini slucajeva, medjutim zamislite da morate da cekate na izvrsavanje nekog timera od pet sekundi da istekne. Za tih 5 sekundi nista na stranici ne bi radilo. Upravo tu upada u pomoc asinhroni kod. Sledeci primer pokazuje taj timer od pet sekundi. 

const p = document.querySelector('.p');
setTimeout(function() {
    p.textContent = 'My name is Jonas!';
}, 5000)
p.style.color = 'red';

Prva linija koda je i dalje sinhrona, tako da ce se izvristi odmah i execution context odmah prelazi na drugu liniju koda. Ali ovde dolazimo do setTimeout funkcije. Ona ce da startuje timer ali na asinhroni nacin. To znaci da ce taj timer da tece u pozadini bez sprecavanja i blokiranja ostatka koda ispod njega. Takodje ovde u timeru registrujemo call back funkciju koja nece biti izvrsena sada vec tek nakon sto timer zavrsi odbrojavanje u pozadini. Ova callback funkcija je upravo asinhroni javascript. Asinhroni je zato sto ce se izvristi tek nakon sto se taj task koji je pokrenut u pozadini zavrsi. To znaci da se registruje callback funkcija (timer se pokrece u pozadini) a nas kod nastavlja odmah sa izvrsavanjem sledece linije koda p.style.color = 'red' bez bilo kakvog blokiranja i zadrzavanja. Tako da glavni kod nije blokiran a izvrsavanje NE CEKA na asinhroni timer da zavrsi svoj poso. To je velika razlika izmedju sinhronog i asinhronog koda. Kada timer konacno zavrsi odbrojavanje od pet sekundi callback funkcija ce konacno biti izvrsena. Dakle ta callback funkcija ce biti izvrsena na kraj ovog koda iako se u kodu ne nalazi na kraju. Asinhron bukvalno znaci da se ne desava u isto vreme. Kao sto smo videli u ovom primeru morali smo da koristimo callback funkciju kako bi primenili to asihrono ponasanje. Medjutim TO NE ZNACI da callback funkcije automatski cine kod asinhronim. Npr array metoda MAP prihvata callback funkciju, medjutim to je ne cini asihronom. Samo specificne funkcije rade na asinhroni nacin (timeri na primer).

Evo jos jedan primer asinhronog koda:

const img = document.querySelector('.dog');
img.src = 'dog.jpg';
img.addEventListener('load', function() {
    img.classList.add('fadeIn');
})
p.style.width = '300px';

Prve dve linije se izvrsavaju sinhrono, jedna za drugom. U drugoj liniji postavljamo src atribut slici koju smo selektovali u prvoj liniji koda. Ova operacija je zapravo asinhrona. Setovanje src atributa na bilo kojoj slici je asinhrona operacija. Jer to zapravo ucitava sliku u pozadini, dok ostatak koda nastavlja da se izvrsava. Ovo naravno ima smila jer zamislite da je slika ogromna, naravno da ne bi voleli da cekamo na nas kod da se ucita cela slika, zato je setovanje src atributa u js asinhrono. Nakon sto se slika ucitala, 'load' event ce da bude emitovan od strane javascripta, tako da mozemo da osluskujemo taj load event i da vrsimu neku akciju usled ucitavanja slike. To je upravo ono sto se desava ovde u kodu. To radimo upravo na trecoj liniji koda. Koristimo addEventListener da bi registrovali callback funkciju za load event. Bas kao u prethodnom primeru obezbedili smo callback funkciju koja ce da bude izvrsena tek kada se slika ucita. Upravo to cini ovaj kod non-blocking. Umesto da blokiramo kod izvrsvanje odmah nastavlja dalje u kodu. I tek kada se slika kompletno ucita, prikazuje se na stranici i load event je emitovan. Posto mi slusamo taj event nasa callback funkcija je konacno izvrsena. Jos jedna bitna stvar da napomenmo jeste da addEventListener ne cini kod asinhronim, bas kao i call back funkcije koje same po sebi ne cine kod asinhronim! Na primer event listener koji osluskuje click na nekon buttonu ne radi nikakav poso u pozadini, prosto ceka na click da se desi, tako da tu ne postoji nikakav asinhroni kod. U primeru iznad sve sto cini kod asinhronim jeste sto slika ucitava asinhrono i mi osluskujemo taj load event preko addEventListener funkcije i cekamo da se desi. Naravno da postoji jos mnogo primera asinhronog ponasanja u javascriptu. AJAX pozivi se smatraju vrv medju najpopularnijim asinhronim kodom u javascriptu. 

Sta je to AJAX zapravo?
AJAX je skracenica za Asynchronous Javascript And XML. On nam omogucava da komunicramo sa remote serverima na asinhroni nacin. U praksi mi radimo ajax pozive u nasem kodu kako bi zahtevali neke podatke od nekog web servera dinamicno, bez reloadovanja stranice. 
Kako zapravo AJAX funckonise? Recimo da imamo nasu javascript aplikaciju koja je pokrenuta u pretrazivacu, sto se drugim recima naziva klijent. Mi zelimo od nase aplikacije da dostavimo neke podatke od web servera, recimo podatke o nekim drzavama. Uz pomoc AJAX mozemo da radimo HTTP request (zahteve) prema serveru koji poseduje ove podatke koji nama trebaju. Zatim ce server da posalje response (odgovor) koji sadrzi te podatke koje smo mi od njega prvobitno trazili. Ova proces od klijenta do servera i nazad se desava asinhrono u pozadini. Naravno postoje razliciti tipovi request-a kao sto su GET request da bi dobili podatke, POST request da posaljem neke podatke na server, PATCH/PUT request da editujemo neke postojece podatke itd. 

Kada smo pitali srever da nam posalje neke podatke ovaj server obicno sadrzi nesto sto se zove web API. Ovaj web api sadrzi podatke koje smo mi zatrazili. Ali sta je zapravo API?

API je skracenica za Application Programming Interface. API je deo softvera koji moze da se koristi od strane dugog dela softvera, sto prakticno omogucava da aplikacije komunicairaju medjusobno i da razmenjuju informacije. To nije slucaj samo sa web developmentom vec generalno sa programiranjem. U javascriptu i uopste u web developmentu postoji bezbroj api-a, kao sto je DOM API, geolocation API, fetch API itd. Oni se nazivaju api-ima jer su samostalni delovi softvera koji omogucavaju drugim delovimam softvera da komuniciraju izmedju sebe.  

E sada da pricamo o API-ima za koje smo mi zainterosavni u web developmentu. Drugacije ih nazivamo "Online" API. Online api je aplikacija koja je pokrenuta negde na serveru koja prima zahteve za podatke zatim vadi ovde podatke iz neke baze podataka i najzad salje ih nazad klijentu. Ove "Online" apie prosto zovemo samo API, cak moze da se cuje i naziv WEB API. Naravno mi mozemo da naparvimo sami neki WEB API ali to bi zahtevalo backend development, dakle development sa serverima, bazama podataka i ostalo...

Na frontu mi smo zainterosavni za koriscenje 3rd-party API-a, dakle API-e koje drugi developeri cine dostupnim za nas potpuno besplatno (u vecini slucajeva). Postoje api-i za svasta nesto, tipa: podaci o vremenu, podaci o drzavama i gradovima, podaci o letovima, api-i za slanje mejlova i poruka...

Na kraju da spomenemo format podatka api-a. Kao sto smo rekli AJAX je skracenica za Asynchronous Javascript and XML, XML je zapravo fomrat podataka koji je pre koriscen za slanje podatka na webu. Medjutim ovih dana ni jedan api ne koristi vise XML format podataka. Umesto toga vecina api-a danas koristi JSON format podataka. To je prakticno javascript objekat ali konvertovan u string. To ga cini vrlo pogodnim za slanje izmedju klijenta i servera, kao i da se vrlo lako korsti u javascriptu kada podaci dodju do klijenta. 


U javascriptu zapravo postoji mnogo nacina da se odradi AJAX poziv ka serveru. Najvise 'old school' nacin bi bio preko XMLHttpRequest funckije. Ovo je bas star nacina da zatrazimo nesto od servera, medjutim mozda ce vam zatrebati nekad u budcnosti i zato krecemo od njega. Druga stvar jeste da pokazemo kako su AJAX pozivi bili regulisani preko eventa icallback funkcija. Tek nakon doga precicemo na moderniji nacin cinjenja AJAX poziva koji obuhvata promise. 

Prvo sto moramo da uradimo jeste da pozovemo konstrutkro funckiju i da uskladistivmo taj rezultat u neku promenljivu: 

const request = new XMLHttpRequest();

...zatim moramo da postavimo koji request zelimo i prema kom endpointu zelimo da saljemo request. To radimo tako sto pozivmao metodu open() nad requestom koji smo uskladistili kada smo pozvali XMLHttpRequest. Prvi argument open metode jeste vrsta requesta (get, post, delete, patch, put...) a drugi argument jeste endpoint koji gadjamo da bi dobili te podatke koje zelimo.

request.open('GET', 'https://restcountries.com/v3.1/name/serbia');

...treci korak bi bio slanje zahteva, to radimo pomocu metode send();

request.send();

...medjutim ono sto je interesantno ovde jeste da ako sada zelimo da dobijemo te podatke koje vraca server ne mozemo samo da uskladistimo request.send() u neku promenljivu. Razlog zasto to ne mozemo da uradimo jeste zato sto rezultat jos uvek nije tu u tom trenutku kada bi mi smestili rezultat request.send() u neku promenljivu! Taj AJAX poziv koji smo poslali se desava u pozadini, dok ostatak koda nastavlja da se izvrsava. Ono sto moramo da uradimo ovde jeste da registrujemo callback funkciju na request objektu za load event. Mi smo sa send() metodom poslali request ka serveru medjutim ono sto on radi jeste da ce da emituje load event koji mi mozemo da slusamo i cim ti podaci dodju do nas pokrenuce se callback funkcija koju smo definisali u addEventListeneru.

request.addEventListener('load', function() {
    console.log(this.responseText);
})

...kao sto vidimo dosta veliki setup samo oko jednog poziva, ali tako je bilo nekad kada se koristio XMLHttpRequest. Danas moderni javascript ima bolje nacine za pravljenje AJAX poziva ka serveru. 


KAKO FUNKCIONISE WEB - ZAHTEVI I ODGOVORI (REQUESTS AND RESPONSE)
Kad god pokusamo da pristupimo web serveru, nas browser odnosno klijent, salje zahtev (request) serveru a onda ce server da posalje nazad odgovor  (response). Taj response sadrzi podatke koje smo mi zatrazili od web servera. 

https://restcountries.com/v3.1/name

... svaki url sadrzi u sebi http ili https sto je naziv za protokol koji ce da se koristi u konekciji. Zatim imamo domain ime (sto je uvom slucaju restcountries.com) i posle / imamo takozvani resource kom zelimo da pristupimo (/v3.1/name). Ovo domain ime (restcountries.com) nije prava adresa ka serveru kom zelimo da pristupimo, to je samo apstrakcija u obliku imena da bi nam bilo lakse da zapamtimo, to znaci da nam je potreban nacin da konvertujemo domain ime u pravu adresu servera. To se desava preko DNS-a. DNS je skracenica za Domain Name Server, to je specijalna vrsta servera, oni su kao telefonski imenik interneta. Prva stvar koja se desava kada pristupimo nekom web serveru jeste da nas browser napravi request (zahtev) ka tom DNS serveru i onda ovaj specijalni server uklapa web adresu tog url-a koji gadjamo sa serverovom pravom ip adresom. Sve se ovo desava preko vaseg internet provajdera. Nakon sto DNS server obradi domain ime i pretvori ga u pravu ip adresu servera, salje ga nazad browseru (klijentu). Tako da sada konacno mozemo da pozovemo server sa tom pravom ip adresom. Tako da bi prava adresa izgledala nesto ovako (https://104.27.142.889:443). Dakle adresa i dalje ima protokol (https) zatim ide ip adresa i na kraju port kom pristupamo na serveru. Ovaj port broj sluzi samo da bi identifikovali odredjeni servis koji se pokrece na serveru. Na taj port mozemo da gledamo kao na pod adresu (port number: default 443 for https, 80 for http). Sada kada imamo pravu ip adresu TCP socket connection je ustanovljen izmedju browsera (klijenta) i servera, tako da su ta dva sada konacno konektovana. Ova konekcija postoji sve vreme dok prebacimo sve podatke izmedju klijenta i servera. Sta je to zapravo TCP/IP? TCP je skracenica za transmisison control protocol (protokil kontrole prenosa), dok IP jeste skracenica za Internet Protocol. Zajedno cine komunikacione protokole koji definisu tacno kako podaci putuju preko weba. Oni su fundamentalni za kontrolni centar interneta. Oni postavljaju pravila kako se razmenjuju podaci preko interneta. Sada kada je ustanovljena veza izmedju naseg browsera (klijenta) i servera, konacno mozemo da posaljemo nas HTTP zahtev. HTTP je skracenica za hyper text transfer protocol. Taj http je jos jedan komunikacionin protokol. Komunikacioni protokol je sistem pravila koji dozvoljava dvema ili vise stranama da komuniciraju. U slucaju HTTP-a to je samo protokol koji dozvoljava klijentu i web serveru da komuniciraju. To funkcionise tako sto klijent salje request poruke a od servera dobija response poruke. Ta request poruka izgleda otprilike ovako: 

GET /v3.1/name/{name of the country}/PT HTTP/1.1

Host: www.google.com
User-Agent: Mozilla/5.0
Accept-Language: en-US

<BODY>

Pocetak poruke je najvazniji deo poruke. On sadrzi http metod koji se koristi u requestu, zatim request target i http verzija. Od svih http metoda najvaznije su GET za dobijanje podataka od servera, POST za slanje podataka od klijenta ka serveru, PUT/PATCH sluze za modifikovanje podataka na serveru i DELETE koji sluzi da obrisemo nasto neki podatak sa servera. Sto se tice request targeta (/v3.1/name/{name of the country}) ovde se kaze serveru da zelimo da pristupimo /v3.1/name/{name of country} resurs. Ako je ovaj target prazan onda bi pristupali root servera. 
Sledeci deo request poruke jeste request headers. U njemu se nalaze informacije o samom zahtevu (requestu). Npr koji browser koristimo, koje vreme saljemo request, koj jezik koristi user itd. I na kraju u slucaju da saljemo podatke serveru (post, put/patch) takodje ce postojati request body i taj body ce naravno da sadrzi podatke koje saljemo serveru, npr podatke iz html forme. 

Spomenuli smo gore da postoje HTTP i HTTPS protokoli. Glavna razlika izmedju njih je sto je HTTPS enkriptovan TLS/SSL, koji su zapravo samo jos protokola. U prevodu HTTPS protokol je sigurniji od HTTP-a. 

Sada kada je nas zahtev (request) dosao do servera, sada ce server obraditi nas request dok ne prikupi nase podatke ili web stranicu i poslace ih nazad ka klijentu. Kada ti podaci budu spremni poslace ih nazad preko http responsa. Ta http response poruka izgleda jako slicno kao http request poruka:

http response bi izgledao nesto ovako: 

HTTP/1.1 200 OK 

Date: Fri, 18 Jan 2022
Content-Type: text/html
Transfer-Encoding: chunked

<BODY>

Vrh ove poruke pored http verzije sadrzi status kod i status poruku. Oni se koriste da obaveste klijenta da li je zahtev bio uspesan ili ne. Npr 200 znaci OK, sve je u redu. Takodje jos jedan poznati status kod 404 koji predstavlja NOT FOUND. Response headers su informacije o odgovoru. Poslednja stvar u odgovoru jeste body, koji je prisutan u vecini odgovora (responsa). Uglavnom sadrze JSON podatke koji dolaze nazad sa API-a ili html web stranicu koju smo prethodno zatrazili. 

Mi smo u nasoj aplikaciji za sada napravili samo jedan request ka serveru ka restcountries.com i dobili jedan odgovor nazad. Medjutim ako pristupamo web stranici postojace mnogo zahteva i odgovora to je zato sto kada cinimo prvi zahtev sve sto dobijamo nazad jeste samo pocetni html fajl, zatim se taj html fajl skenira od strane browsera za sva sredstva koja su mu potrebna da bi napravio celu web stranicu, kao sto je javascript fajlovi, css fajlovi, sve slike koje mozda postoje na toj web stranici. Za svaki fajl ce postojati novi http request ka serveru. Naravno moguce je da se vise istovremenih poziva i odgovora desavaju u isto vreme. I na kraju kada svi fajlovi stignu do klijenta (browsera) celokupna stranica moze da bude ucitana na osnovu html-a, css-a i javescript-a.

Nesto vise o TCP/IP protokolima. Rekli smo da su to protokoli koji definisu kako podaci putuju preko weba. Zadatak TCP protokola jeste da razbije na vise komada zahteve i odgovore na hiljade malih komada. Jednom kada svi ti paketi stignu do svoje finalne destinacije, TCP protokol ce spojiti sve te pakete u originalni zahtev ili odgovor. Ovo je neophodno da bi svaki paket mogao da uzme drugu rutu kroz internet. Posto na ovaj nacin poruka dolazi do svoje destinacije najbrze moguce, sto ne bi bilo moguce ako posaljemo sve podatke kao jedan veliki paket. Sto se tice IP protokola, njegov zadatak jeste da da posalje i rutira ove sitne pakete kroz internet. On osigurava da stignu do destinacije do koje treba da dodju koristeci IP adrese na svakom paketu. 


PROMISES:
Do sada smo koristili XMLHttpRequest za pravljenje asinhronih odnosno AJAX poziva ka serveru, gde smo morali da konfigurisemo taj poziv sa .open() metodom, zatim da koristimo .send() metodu da posaljemo taj AJAX poziv i na kraju da regulisemo odgovor tako sto cemo da slusamo load event na tom zahtevu i da odredimo callback funkciju koja ce da se postara za odgovor servera. Medjutim postji dosta laksi nacin a to je da koristimo fetch() funkciju. Ta fetch funkcija odmah vraca promise. Medjutim sta je to promise? Formalna definicija promisa jeste da je to objekat koji se koristi kao neki cuvar mesta za buduci rezultat asinhrone operacije. Manje formalna definicija bi bila da je promis kontejner za asinhrono isporucenu vrednost, ili jednostavno promise je kontejner za buducu vrednost. Odlican primer za buducu vrednost jeste odgovor AJAX poziva. Kada startujemo AJAX poziv u tom trenutku jos uvek ne postoji vrednost, ali znamo da ce u nekom trenutku u buducnosti ta vrednost doci do nas, tako da mozemo da koristimo promise da regulisemo ovu buducu vrednost. E sad koja je prednost koriscenja promisa? Zapravo postoje dva razloga za koriscenja promisa. Prvo koristeci promise vise ne moramo da se oslanjamo na evente i callback funkcije koje ce da regulisu asinhronu operaciju. Drugi razlog zasto su promisi bolji jeste da mozemo da ih vezujemo jedan za drugim i tako da imamo vise asinhronih operacija bez da gnezdimo jednu callback funkciju unutar druge i tako pravimo callback hell. Promisi su predstavljeni 2015e godine sa dolazkom ES6 standarda. Posto promisi rade sa asinhronim operacijama oni su osetljivi na vreme, dakle menjaju se vremenom. To znaci da promis moze da bude u vise stanja! To se zove zivotni put (life cicle) promisa. Na samom pocetku kazemo da je promise u pending fazi. Ovo je slucaj kada vrednost od asinhronog poziva jos uvek nije dostpuna. U ovom trenutku asinhroni zadatak jos uvek radi svoj poso u pozadini. Kada se taj asinhroni task konacno zavrsi kazemo da je promise settled. E sad postoje dva razlicita tipa settled promisa. Prvi je fullfilled (ispunjen) promis a drugi je rejected (odbijen) promise. Ispunjen (fullfilled) promis je promis koji je uspesno rezultirao u vrednost koju smo ocekivali. Npr ako koristimo promis da potrazimo podtake od servera, fullfilled (ispunjen) promis ce uspesno dostaviti te podatke do nas i sada su dostpune da koristimo te podatke koje smo trazili od servera. Na drugu stranu rejected (odbijeni) promis znaci da se desila neka greska tokom asinhrone operacije. Ako opet pogledamo primer gde zahtevamo neke podatke od servera, greska bi bila kada je user offline i ne moze da se konektuje na api server. Naravno mi u kodu koristeci fetch funckiju mozemo da regulisemo i fullfilled (ispunjeni) promis kao i rejected (odbijeni) promis. Bitna stvar vezana za promise jeste da se promis uredjuje (bude settled) jednom. Odatle njegovo stanje ostaje tako zauvek, nece se vise menjati. Dakle promis je ili fullfilled ili rejected i nemoguce je da promenimo to stanje. Ova dva stanja settled promisa su jako bitna jer nam pomazu da konzumiramo promis. Mi konzumiramo promis kada imamo promis, npr promis koji vraca fetch funkcija kada dobavljamo neke podatke od servera. Da bi promis uopste postojao, on mora prvo da bude izgradjen, mora da bude kreiran. U slucaju fetch API-a, upravo fetch funkcija gradi taj promis i vraca ga nama da ga konzumiramo. U slucaju fetch funkcije mi nemoramo da pravimo sami promis vec ce ga za nas izgraditi fetch funkcija. U vecini slucaja mi cemo konzumirati promise, medjutim naravno da mozemo i sami da napravimo promis.  

KONZUMIRANJE PROMISA:
Kao sto smo rekli kada pozovemo fetch funkciju ona ce odmah vratiti promis. Medjutim taj promis kao sto smo rekli bice u pending fazi, odnosno taj asinhroni zadatak jos uvek traje u pozadini. U nekom trenutku taj promis bice settled. Kao sto znamo taj settled promis ima dva stanja. Prvi je u slucaju da je promis uspesan (fullfilled) a drugi je da je odbijen (rejected). Da pretpostavimo da je promis za sada bio uspesan i da mi imamo dostupnu vrednost koja dolazi od servera sa kojom mozemo da radimo, da bi rukovali tim podacima odnosno fullfilled stanjem promisa mozemo da koristmo then() metodu. Ta then() metoda bice dostpuna na svim promisima. 

fetch(`https://restcountries.com/v3.1/name/${country}`).then(function(response) {
    return response.json()
}).then(function(data) {
    console.log(data)
})

...ako znamo da fetch funkcija vraca promis onda mozemo da nadovezemo metodu then() posto je ona dostupna na svemu sto vraca promis. 
Unutar then() metode moramo da prosledimo callback funkciju koja zelimo da se izvrsi cim promis bude fulfilled (ispunjen). Ova callback funkcija koju odredjujemo unutar then() metode primice jedan argument kada je bude pozvao js i taj argument je rezultat tog fulfilled promisa. Ovo je nacin kako se nosimo sa ispunjenim promisom. Odgovor servera koji zapravo trazimo bice unutar tog response argumenta pod svojstvom body. Medjutim mi jos uvek ne mozemo da radimo s tim podacima, tj ne mozemo da ih procitamo. Da bi mogli da procitamo te podatke ono sto moramo da uradimo prvo jeste da pozovemo .json() metodu na tom responsu. .json() metoda bice dostpuna na svim responsima fetch funkcije. E sad problem ovde jeste sto .json() metoda takodje asinhrona funkcija. To znaci da vraca novi promis. Ono sto moramo da uradimo jeste da vratimo novi promis iz then() metode (vidi primer gore). Ako sada .then() metoda vraca novi promis to znaci da moramo da ga regulisemo. To radimo opet sa .then() metodom, jer kao sto znamo .then() metoda je dostpuna na svemu sto vraca promis. Prica je opet ista, u toj drugoj .then() metodi moramo da definisemo callback funkciju koja ce da primi argument, koji ce zapravo da predstavlja podatke koje ocekujemo od servera. 
Ono sto cini promise jako dobrim za koriscenje jeste sto mozemo da ih nadovezujemo jedan za drugim. Gore u primeru se vec vidi primer tog nadovezivanja. Ono sto je bitno da razumemo jeste da .then() metoda UVEK vraca promis, bez obzira na to da li mi vratili nesto iz nje ili ne. Ali ako ipak vratimo neku vrednosti iz .then() metode onda ce ta vrednost da postane fullfillment (ispunjena) vrednost od vracenog promisa. 

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => response.json())
    .then((data) => {
      const neighbor = data[0].borders?.[0];

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json())
    .then((data) => renderCountry(data[0], "neighbor"));
}

getCountryData("finland");

U ovom slucaju prvo pozivamo prvu drzavu, cim dobijemo njene podatke, nalazimo jednu od border drzava i pravimo novi zahtev ka serveru sa tom borderom drzavom. Tako da ce sada js uvek izvrsiti poziv prve drzave pa tek onda poziv druge drzave. U drugoj .then() metodi izvukli smo neighbor drzavu i napravili novi fetch poziv, koji vracamo iz te druge .then() metode sto znaci da ona sada vraca promis koji mozemo dalje da regulisemo. 
Naravno da ovde mozemo da nastavimo niz i da vezujemo dalje promise i da ih regulisemo sa .then() metodama!


HANDLING REJECTED PROMISES:
Do sada smo pretpostavili da je sve u redu sa nasim promisom, medjutim kao sto znamo pored ispunjenog promisa, posotji i rejected odnosno odbijeni promis. Ukoliko dodje do odbijenog promisa to takodje moramo da resimo u nasem kodu. Dakle promis u kom se desila greska jeste rejected (odbijeni) promis. Kako da se nosimo sa tim odbijenim promisom? 
Jedini put kada ce promis da bude odbijen u slucaju fetch funckije jeste kada korisnik izbubi internet konekciju!
Postoje dva nacina da se regulisu odbijeni (rejected) promisi. Prvi nacin jeste da se prosledi druga callback funkcija unutar .then() metode. Tako da ce prva callback funkcija unutar .then() metode da bude pozvana kada je promis fullfilled (uspesan), a druga callback funkcija bi bila pozvana ukoliko bi doslo do greske i nas promis bude odbijen (rejected). Ta druga callback funkcija koja ce da regulise odbijeni promis prima jedan argument a to je zapravo sam error koji se desio. Na taj nacin mozemo da uhvatimo error unutar naseg promisa i da ga prikazemo korisniku. Ono sto je bitno da razumemo ukoliko se desila neka greska prilikom fetchovanja podataka i nas promis bude odbijen, mi hvatamo tu gresku u drugoj callback funkciji .then() metode i tu prestaje nase nadovezivanja .then() metodama. 

fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => response.json(), (error) => alert(error))

...medjutim sta ako se greska nije desila u ovom prvom delu fetch funckije nego negde kasnije u kodu, kasnije u nasem povezivanju .then() metoda? Sta ako je ovaj prvi promis bio ispunjen a da promis druge fetch funkcije (koja poziva drugu drzavu) bude odbijen usled neke greske? Tada bi morali da regulisemo gresku u .then() metodi posle tog drugog fetch poziva. 

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(
      (response) => response.json(),
      (err) => alert(err)
    )
    .then((data) => {
      const neighbor = data[0].borders?.[0];

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json(), (error) => alert(error))  // i ovde smo morali da definisemo drugu callback funkciju unutar .then() metode kako bi regulisali odbijeni
    .then((data) => renderCountry(data[0], "neighbour"));             promis usled druge fetch funkcije koja poziva neighbor drzavu. 
}

Ovo postaje dosta naporno, da regulisemo greske na vise mesta. Na svu srecu postoji dosta bolje resenje za hvatanje i resavanje gresaka usled odbijenog promisa. Zapravo postoji nacin gde mozemo da regulismo error na jednom mestu. Umesto svih ovi callback funckija koje smo definisali kao druge argumente .then() metoda, mozemo da pozovemo .catch() funkciju i ona ce da uhvati gresku za nas, gde god da se desila u ovom nizu .then() metoda! Toj catch() funkciji takodje prosledimo callback funkciju koja ce da bude pozvana ukoliko dodje do greske bilo gde u nasem lancu .then() metoda. Ta callback funkcija ce da primi error objekat kad argument, da ne bi prikazivali ceo error objekat, taj error objekat u sebi ima message svojstvo koje mozemo da iskoristimo da prikazemo samo poruku a ne ceo error objekat.  

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => response.json())
    .then((data) => {
      const neighbor = data[0].borders?.[0];

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json())
    .then((data) => renderCountry(data[0], "neighbour"))
    .catch((error) => alert(error)); 
}

...ova catch() metoda na kraju niza ce bukvalno uhvatiti bilo koju gresku koja se desilo bilo gde u ovom celom nizu promisa, bez obzira gde se greska desila. Cim neki promis bude obijen on biva prosledjen do kraja odnosno do catch() funkcije. 

Na kraju postoji jos jedna metoda koju bi trebali da napomenemo a koja je isto dostpuna na svim promisima. Dakle pored .then() i .catch() metode postoji i treca koja se zove .finally() metoda. Ta finally() metoda bi uvek trebala da ide na kraju lanca posle svih .then() metoda kao i posle .catch() metode. Finally() metoda ce raditi zato sto i .catch() metoda vraca promis, sto nam govori da finally() metodu mozemo da pozovemo samo na necemu sto vraca promis. Finally() metodi isto tako definisemo callback funkijcu i ona ce uvek da bude pozvana ne vezano za to kakav je nas promis, da li je uspesan ili odbijen. Dakle .finally() metode ce uvek da bude pozvana! Za razliku od .then() metode koja ce da se pozove jedino ako je nas promis uspesan (fullfilled) a .catch() ce da bude pozvana samo ukoliko se desi neka greska. Finally metodu mozemo da koristimo ako znamo da nesto treba da se desi nevezano za to da li je nas promis bio uspesan ili ne. Npr to moze da bude da sakrijemo load spiner ukolko postoji na nasoj stranici. Dakle ako prikazemo neki spiner kada krenemo da fetcujemo podatke sa servera i onda na kraju da ga sakrijemo kada se operacija zavrsi. A to ce se desiti ne vezano za to da li je nas promis bio uspesan ili ne!

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => response.json())
    .then((data) => {
      const neighbor = data[0].borders?.[0];

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json())
    .then((data) => renderCountry(data[0], "neighbour"))
    .catch((error) => {
      renderError(`Something went wrong ðŸ’¥ðŸ’¥ðŸ’¥. ${error.message}`);
    })
    .finally(() => {
      countriesContainer.style.opacity = 1;
    });
}

btn.addEventListener("click", function () {
  getCountryData("italy");
});


THROWING ERROR MANUALLY:
Gore smo prikazali kako da uhvatimo gresku ukolko promis bude odbijen. Medjutim dobra aplikacija ima i dobro resene greske koje mogu da nastanu usled njenog koriscenja. Sta ako u gornjem primeru pozovemo getCountryData('blabla') sa nekom zemljom koja ne postoji? Nasa .catch() funkcija ce uhvatiti gresku ali ona nece biti precizno odredjena. Kao sto smo rekli fetch funkcija vraca gresku samo ukolko korisnik nije konektovan na internet. Ukolko je greska kao u opisanom slucaju 404 (not found) jer ne mozemo da nadjemo drzavu 'blabla' to moramo sami da regulisemo i da napravimo nasu gresku za to!

Ako zelimo da sami napravimo gresku to mozemo da ucinimo preko konstruktor funkcije ovako:

throw new Error('ovde prosledjujemo message svojstvo');

...new Error() je pozivanje konstruktor funkcije dok 'throw' kljucna rec odmah prekida izvrsavanje trenutne funkcije bas kao sto i return radi. Efekat kreiranja greske na ovaj nacin jeste da ce promis odmah da bude odbijen (reject). To znaci da ce trenutni blok .then() bloka odmah da bude prekinut i taj .then() ce da vrati odbijeni promis koji ce da bude uhvacen i catch bloku.

SVAKA GRESKA UZROKOVACE DA PROMIS BUDE ODBIJEN (REJECT)!!!

fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => {
      if (!response.ok) {
        throw new Error('Country not found')  // ako smo throw new Error() definisali ovde u ovoj then metodi ona ce odmah vratiti odbijeni promis. Zatim ce taj odbijen promis
      }                                          odmah da bude uhvacen u catch funkciji. 

      return response.json();
    }).catch(error => {
      alert(error.message)
    })

Ta poruka koju smo prosledili kada smo konstruisali nas Error u ovom slucaju 'Country not found' bice prosledjena sve do catch bloka u njegovom parametru koji prima pod svojstvom error.message.

Medjutim sta ako se greska nije desila u prvom fetch pozivu. Sta ako je tu sve u redu a tek u drugom fetch pozivu za neighbor drzavu postoji greska. To cemo onda handlovati u trecoj .then() metodi odmah ispod .then() metode koja vraca fetch() poziv za neighbor drzavu.

function getCountryData(country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then((response) => {
      if (!response.ok) {
        throw new Error(`Country not found ${response.status}`);
      }

      return response.json();
    })
    .then((data) => {
      const neighbor = 'blabla';

      renderCountry(data[0]);

      if (!neighbor) return;

      return fetch(
        `https://restcountries.com/v3.1/alpha/${neighbor.toLowerCase()}`
      );
    })
    .then((response) => response.json())
    .then((data) => renderCountry(data[0], "neighbour"))
    .catch((error) => {
      renderError(`Something went wrong ðŸ’¥ðŸ’¥ðŸ’¥. ${error.message}`);
    })
    .finally(() => {
      countriesContainer.style.opacity = 1;
    });
}

...jos jedno mesto koje bi koristili da handlujemo gresku manuelno jeste ukolko ne postoji neibhour drzava (npr za ostrva). Mogli bi kod uslova:

if (!neighbor) return 

...umesto ovog mogli bi da napisemo nesto ovako:

if (!neighbor) {
  throw new Error(`There is no neibhour country for ${country}`)
}

...ovo bi predstavljalo mnogo jasniju gresku za korisnika.